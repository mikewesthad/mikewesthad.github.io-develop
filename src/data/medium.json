[
  {
    "title": "Modular Game Worlds in Phaser 3 (Tilemaps #4) - Meet Matter.js",
    "pubDate": "2018-08-08 03:08:41",
    "link":
      "https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1?source=rss-cc77752d538d------2",
    "guid": "https://medium.com/p/abf4dfa65ca1",
    "author": "Michael Hadley",
    "thumbnail": "https://cdn-images-1.medium.com/max/750/1*TMWo_mBNrA9StXQYj_T7FQ.gif",
    "description":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #4) — Meet Matter.js</h3>\n<p>This is the fourth post in a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this edition, we’ll get acquainted with Matter.js, so that we can set up a world with “realistic” physics:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*TMWo_mBNrA9StXQYj_T7FQ.gif\"><figcaption><em>Dropping </em><a href=\"https://github.com/twitter/twemoji\"><em>Twemoji</em></a></figcaption></figure><p>This will set us up for the next post where we’ll ditch the emoji and add a player jumping around this world.</p>\n<p>If you haven’t checked out the previous posts in the series, here are the links:</p>\n<ol>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">Static tilemaps &amp; a Pokémon-style world</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">Dynamic tilemaps &amp; puzzle-y platformer</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd\">Dynamic tilemaps &amp; Procedural Dungeons</a></li>\n</ol>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-4\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser tutorial and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>Overview</h3>\n<p>As I was writing up this post, I realized that there were just too many new concepts to pack into one post, so I’m splitting this into two posts. This one will introduce the Matter physics engine by itself, and then we’ll bring in Phaser, tilemaps and mapping tile bodies in Tiled. In the second post, we’ll dive into Matter’s collision logic and build a platformer.</p>\n<p>A quick sidebar: this whole tutorial series is tilemap-centric, so of course we are going to use tilemaps here. That said, the game/art/tool/etc. that you may want to create might not need a tilemap, e.g. this <a href=\"https://codepen.io/lonekorean/pen/KXLrVX\">pinball game</a> made with Matter. Don’t feel constrained to tilemaps just because we are using them here! You’ll learn the basics of Matter along the way here, so you’ll still get something out of following along even if you don’t use tilemaps.</p>\n<h3>Introduction to Matter</h3>\n<p><a href=\"http://brm.io/matter-js/\">Matter</a> is another JavaScript 2D physics engine. Whereas arcade physics (AP) in Phaser aims to be fast and simple (mainly just axis-aligned bounding boxes and circles), Matter is a more realistic physics simulation engine — complex body shapes, mass, density, constraints, etc.</p>\n<p>AP is perfect if you have a game where you can get by with boxes &amp; circles, but if you want to do something like create physics puzzles in your world (Angry Birds, Crayon Physics, etc.), Matter is the way to go. For example, here’s the slingshot demo from the Matter site (click and drag the blue shape on the left):</p>\n<a href=\"https://medium.com/media/074fa9264fa054c1559e793bb9cb779c/href\">https://medium.com/media/074fa9264fa054c1559e793bb9cb779c/href</a><p>You’ll definitely want to play around with the <a href=\"http://brm.io/matter-js/demo/\">other demos</a> on the Matter site to get a feel for what Matter can do. You’ll also want to keep the <a href=\"http://brm.io/matter-js/docs/\">Matter docs</a> handy.</p>\n<h3>First Steps with Matter</h3>\n<p>Phaser’s implementation is a thin wrapper around the underlying Matter library, so if we want to use Matter in Phaser, we should start with learning Matter by itself. We’ll create a simple setup where you can drop random shapes into a world:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*khg6hhFeOxqrdmB-oLqodw.gif\"></figure><p>Matter is structured around modules that contain factory functions for creating objects, and functions that can manipulate those objects. For example, the Body module is about creating &amp; manipulating <a href=\"https://www.quora.com/What-is-a-rigid-body\">rigidbodies</a>, so it has the Body.create(...) factory which will create a fresh body object for us, and Body.applyForce(...)which will apply a force to the given body object. So the first step we'll want to take is to alias a few of the modules:</p>\n<a href=\"https://medium.com/media/8516a1de5e10b494178b7c38cd19e7fd/href\">https://medium.com/media/8516a1de5e10b494178b7c38cd19e7fd/href</a><p>Next, we’ll want to create an engine and a renderer. Matter comes packaged with a simple canvas renderer, so we’ll take advantage of that before moving into using Phaser:</p>\n<a href=\"https://medium.com/media/90c566e5554fd498ff078047b178d468/href\">https://medium.com/media/90c566e5554fd498ff078047b178d468/href</a><p>Now that we’ve got a physics simulation engine and renderer, we can add some bodies to the world:</p>\n<a href=\"https://medium.com/media/9ebbe0f6d5da29de82b33b67537e9803/href\">https://medium.com/media/9ebbe0f6d5da29de82b33b67537e9803/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*jz_mJZvRvgg26N0NHqFOsg.gif\"></figure><p>Let’s break that down. Bodies.rectangle(400, 0, 120, 80, { restitution: 0.25, angle: Math.PI / 4 }) will create a new, rectangular physics body. It's positioned using the center of the body as the origin. The last parameter is an object that you can pass in to override the default <a href=\"http://brm.io/matter-js/docs/classes/Body.html#properties\">body properties</a>. We've passed in an angle of Math.PI / 4 radians (45 degrees), which will override the default body rotation, 0 radians. We're passing in a restitution property here which specifies the elasticity of the body. By default it's 0 (inelastic), so we're overriding it to create a slightly bouncy rectangle. Other useful properties include: friction, frictionAir, frictionStatic and density.</p>\n<p>The floor body can't be moved or rotated because we've flagged it as a static body using isStatic. So our rectangle will bounce off the floor without the floor moving.</p>\n<p>We can introduce a few new body types (polygons &amp; circles) and fill out our world:</p>\n<a href=\"https://medium.com/media/ec4f1b381c4050367506b41e68f6faf0/href\">https://medium.com/media/ec4f1b381c4050367506b41e68f6faf0/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*E-nijh7jebMvp9sEfNghUg.gif\"><figcaption>Since the rectangle has the highest friction and lowest restitution, it’s the least bouncy and slippery of the shapes.</figcaption></figure><p>We can also create compound bodies, bodies which have multiple parts that are linked together. The parts will move together as one object:</p>\n<a href=\"https://medium.com/media/af739ff62eb535982f4e93998730d1ab/href\">https://medium.com/media/af739ff62eb535982f4e93998730d1ab/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*bxzNlhrnuqGwaoLfG3ssgA.gif\"></figure><p>The last piece we’ll add is the ability to drop new polygons any time you click on the canvas:</p>\n<a href=\"https://medium.com/media/b8ce8b29a949e10687796b53e4d33c78/href\">https://medium.com/media/b8ce8b29a949e10687796b53e4d33c78/href</a><p>And putting it all together:</p>\n<a href=\"https://medium.com/media/a13d6b6f681c2104428b5a6df8698392/href\">https://medium.com/media/a13d6b6f681c2104428b5a6df8698392/href</a><p>Now that we’ve got the Matter fundamentals, we can turn our attention to working with Matter &amp; Phaser together. Check out this <a href=\"https://code.tutsplus.com/series/getting-started-with-matterjs--cms-1186\">tutorial series</a> by Monty Shokeen if you want to dive deeper into Matter by itself.</p>\n<h3>Matter and Phaser</h3>\n<p>We’ll create something similar to the last example, except we’ll use a tilemap to define the world and we’ll drop some emojis (because why not):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*bhm6OCdBX1XoWnQ732OWIg.gif\"></figure><p>Using the same structure as the last tutorial in this series, we’ll create an index.js file that creates our game and loads a custom scene:</p>\n<a href=\"https://medium.com/media/fe99bd76b64a0ee020cf1746ade4c613/href\">https://medium.com/media/fe99bd76b64a0ee020cf1746ade4c613/href</a><p>Let’s start by creating MainScene which loads up the tilemap and enables physics:</p>\n<a href=\"https://medium.com/media/7356ab597c653e5a0f130bcecb8664a7/href\">https://medium.com/media/7356ab597c653e5a0f130bcecb8664a7/href</a><p>If we look closely, we can see that all the new bodies are rectangles. We’ll get into giving the tiles custom bodies that match their graphics in the next section.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*_hsPeZ-L_0kx51XVpcPWOw.png\"></figure><p>Now, we can drop a couple emojis with circle bodies into our scene using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#image__anchor\">this.matter.add.image</a>. Like with AP, we can create physics enabled images and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#sprite__anchor\">sprites</a> using the this.matter.add <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html\">factory methods</a>. The factory also has methods for creating native Matter bodies and constraints (without any graphics), e.g. this.matter.add.rectangle.</p>\n<a href=\"https://medium.com/media/35ee25c4fb43a81b24dfc8cd7c23e98c/href\">https://medium.com/media/35ee25c4fb43a81b24dfc8cd7c23e98c/href</a><p>These image variables are now instances of <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html\">Phaser.Physics.Matter.Image</a>. They have the properties and methods of a normal Phaser image, but with added methods and properties for manipulating the underlying Matter body. There's a body property which gives you access to the native Matter body, and methods like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setCircle__anchor\">setCircle</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setRectangle__anchor\">setRectangle</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setBody__anchor\">setBody</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setExistingBody__anchor\">setExistingBody</a>, etc. for replacing the image's current body. The same idea applies to <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Sprite.html\">Phaser.Phyiscs.Matter.Sprite</a>.</p>\n<p>Like the Matter example from the previous section, we can add in some emojis every time the left mouse button is pressed by adding the following to our create method:</p>\n<a href=\"https://medium.com/media/f89a6c419fdb75c4d7965071007023b3/href\">https://medium.com/media/f89a6c419fdb75c4d7965071007023b3/href</a><p>And all together:</p>\n<a href=\"https://medium.com/media/40b8a26cce27f262afaacc3d85681c01/href\">https://medium.com/media/40b8a26cce27f262afaacc3d85681c01/href</a><h3>Mapping Collisions Shapes</h3>\n<p>We’ve got our tiles integrated with Matter, but we’ve got a problem. Our bodies are all rectangles, but our tiles aren’t all rectangles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*9GkvEr-xAVIgVMOkr24tVg.gif\"></figure><p>We’re not really taking advantage of Matter’s different body shapes… yet. In Tiled, we can map our collision shapes using the built-in <a href=\"http://docs.mapeditor.org/en/stable/manual/editing-tilesets/\">collision editor</a>. Phaser will automatically parse out circles, rectangles, polygons and compound shapes when we use this.matter.world.convertTilemapLayer(...).</p>\n<p>To map out the shapes in Tiled, we need to:</p>\n<ol>\n<li>Go to the tileset properties window and open the collision editor.</li>\n<li>Click on a tile and map out its body. Repeat for all the tiles that need custom bodies.</li>\n<li>Save the tileset &amp; re-export the tilemap.</li>\n</ol>\n<p>Tiled’s user interface can be a little confusing, so here’s how to open the collision editor:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z2qKsJOR7ToWQYjXLd6bug.gif\"></figure><p>Once we’ve got a tile selected, we’ll have this window to map out the colliding shapes over the tile:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/506/1*vCARWcO6uJ8wK7XuOLwuag.png\"><figcaption>From left to right in the toolbar, the tools are: select object, edit polygon points, create rectangle, create ellipse, create polygon and create polyline. We’ll use all of them except for the polyline.</figcaption></figure><p>Let’s take a look at mapping out a few different tiles. The goal is to use the fewest number of shapes / vertices while still getting decently mapped hitboxes.</p>\n<p>First up, many tiles will work great with just a single rectangle, like this skinny platform:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GgFCvVMBepGtvrQo3svSFA.gif\"></figure><p>(As you are working, you may find it useful to enable or disable the snapping settings: View -&gt; Snapping in the top toolbar. In these GIFs, I have snap to pixels enabled.)</p>\n<p>Sometimes, all you need is a single circle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3JrH70qSpdMyNMyZzB-CnQ.gif\"></figure><p>One gotcha here — Matter doesn’t support ellipses, so any “ellipse” that you create in Tiled is going to be converted into a circle body inside of Phaser.</p>\n<p>Compound bodies made of multiple bodies — like our cross from earlier — can be handy, like for this switch:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*F2DTQ0Q2hvV8t2ER25UYvg.gif\"></figure><p>We can also map out polygons, like using a triangle for this sloped tile. (Press enter to complete the shape after drawing the last vertex.)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Hg8nSnBgK9_L8Tq0oGhOuQ.gif\"></figure><p>Not all polygons are created equal. Convex polygons are usually much easier to deal with than concave polygons:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/509/1*ho-fMU_mCjnT3he2RAy2iQ.png\"><figcaption><em>Play with this </em><a href=\"https://www.mathopenref.com/polygonconvex.html\"><em>tool</em></a><em> to see what I mean by “interior angle.”</em></figcaption></figure><p>Convex polygons will work as expected. Any concave polygon bodies will be decomposed by Matter into a compound body of two or more convex polygons (using <a href=\"https://github.com/schteppe/poly-decomp.js\">poly-decomp.js</a>). If the decomposition fails, the body will set to a <a href=\"https://medium.com/@harshitsikchi/convex-hulls-explained-baab662c4e94\">convex hull</a>. See <a href=\"http://brm.io/matter-js/docs/classes/Bodies.html#method_fromVertices\">Matter docs</a> for more info. I’d recommend sticking to convex polygons, but we can map out a concave polygon for demo purposes:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mSmbXOsIA8lteK6OvsN5gQ.gif\"></figure><p>Save the tileset, re-export the map and we’ll have:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/476/1*VLJAknYYFDbA3bzaYwKKZg.gif\"><figcaption>This isn’t the same map we were using before —it’s just a small demo to show the tiles we just mapped. <em>Note, the debug rendering for the compound bodies — the sign and lava — also renders a convex hull. We’ll talk about that more next time.</em></figcaption></figure><p>In the codesandbox, I mapped out the rest of the tiles we’re using and exported the new map. No real need to change anything in the code to load up these new bodies:</p>\n<a href=\"https://medium.com/media/f532a1ce9de7049566e2032a5e4b67df/href\">https://medium.com/media/f532a1ce9de7049566e2032a5e4b67df/href</a><p>If we needed more control over the bodies given to tiles (or if we weren’t using Tiled), we can loop over the tiles using layer.forEachTile and use <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#tileBody__anchor\">this.matter.add.tileBody</a> to add custom tile bodies to each tile.</p>\n<h3>Up Next</h3>\n<p>Stay tuned. Next up, we’ll use this foundational knowledge of Matter to build a platformer.</p>\n<p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=abf4dfa65ca1\" width=\"1\" height=\"1\"><hr>\n<p><a href=\"https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1\">Modular Game Worlds in Phaser 3 (Tilemaps #4) - Meet Matter.js</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #4) — Meet Matter.js</h3>\n<p>This is the fourth post in a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this edition, we’ll get acquainted with Matter.js, so that we can set up a world with “realistic” physics:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*TMWo_mBNrA9StXQYj_T7FQ.gif\"><figcaption><em>Dropping </em><a href=\"https://github.com/twitter/twemoji\"><em>Twemoji</em></a></figcaption></figure><p>This will set us up for the next post where we’ll ditch the emoji and add a player jumping around this world.</p>\n<p>If you haven’t checked out the previous posts in the series, here are the links:</p>\n<ol>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">Static tilemaps &amp; a Pokémon-style world</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">Dynamic tilemaps &amp; puzzle-y platformer</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd\">Dynamic tilemaps &amp; Procedural Dungeons</a></li>\n</ol>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-4\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser tutorial and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>Overview</h3>\n<p>As I was writing up this post, I realized that there were just too many new concepts to pack into one post, so I’m splitting this into two posts. This one will introduce the Matter physics engine by itself, and then we’ll bring in Phaser, tilemaps and mapping tile bodies in Tiled. In the second post, we’ll dive into Matter’s collision logic and build a platformer.</p>\n<p>A quick sidebar: this whole tutorial series is tilemap-centric, so of course we are going to use tilemaps here. That said, the game/art/tool/etc. that you may want to create might not need a tilemap, e.g. this <a href=\"https://codepen.io/lonekorean/pen/KXLrVX\">pinball game</a> made with Matter. Don’t feel constrained to tilemaps just because we are using them here! You’ll learn the basics of Matter along the way here, so you’ll still get something out of following along even if you don’t use tilemaps.</p>\n<h3>Introduction to Matter</h3>\n<p><a href=\"http://brm.io/matter-js/\">Matter</a> is another JavaScript 2D physics engine. Whereas arcade physics (AP) in Phaser aims to be fast and simple (mainly just axis-aligned bounding boxes and circles), Matter is a more realistic physics simulation engine — complex body shapes, mass, density, constraints, etc.</p>\n<p>AP is perfect if you have a game where you can get by with boxes &amp; circles, but if you want to do something like create physics puzzles in your world (Angry Birds, Crayon Physics, etc.), Matter is the way to go. For example, here’s the slingshot demo from the Matter site (click and drag the blue shape on the left):</p>\n<a href=\"https://medium.com/media/074fa9264fa054c1559e793bb9cb779c/href\">https://medium.com/media/074fa9264fa054c1559e793bb9cb779c/href</a><p>You’ll definitely want to play around with the <a href=\"http://brm.io/matter-js/demo/\">other demos</a> on the Matter site to get a feel for what Matter can do. You’ll also want to keep the <a href=\"http://brm.io/matter-js/docs/\">Matter docs</a> handy.</p>\n<h3>First Steps with Matter</h3>\n<p>Phaser’s implementation is a thin wrapper around the underlying Matter library, so if we want to use Matter in Phaser, we should start with learning Matter by itself. We’ll create a simple setup where you can drop random shapes into a world:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*khg6hhFeOxqrdmB-oLqodw.gif\"></figure><p>Matter is structured around modules that contain factory functions for creating objects, and functions that can manipulate those objects. For example, the Body module is about creating &amp; manipulating <a href=\"https://www.quora.com/What-is-a-rigid-body\">rigidbodies</a>, so it has the Body.create(...) factory which will create a fresh body object for us, and Body.applyForce(...)which will apply a force to the given body object. So the first step we'll want to take is to alias a few of the modules:</p>\n<a href=\"https://medium.com/media/8516a1de5e10b494178b7c38cd19e7fd/href\">https://medium.com/media/8516a1de5e10b494178b7c38cd19e7fd/href</a><p>Next, we’ll want to create an engine and a renderer. Matter comes packaged with a simple canvas renderer, so we’ll take advantage of that before moving into using Phaser:</p>\n<a href=\"https://medium.com/media/90c566e5554fd498ff078047b178d468/href\">https://medium.com/media/90c566e5554fd498ff078047b178d468/href</a><p>Now that we’ve got a physics simulation engine and renderer, we can add some bodies to the world:</p>\n<a href=\"https://medium.com/media/9ebbe0f6d5da29de82b33b67537e9803/href\">https://medium.com/media/9ebbe0f6d5da29de82b33b67537e9803/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*jz_mJZvRvgg26N0NHqFOsg.gif\"></figure><p>Let’s break that down. Bodies.rectangle(400, 0, 120, 80, { restitution: 0.25, angle: Math.PI / 4 }) will create a new, rectangular physics body. It's positioned using the center of the body as the origin. The last parameter is an object that you can pass in to override the default <a href=\"http://brm.io/matter-js/docs/classes/Body.html#properties\">body properties</a>. We've passed in an angle of Math.PI / 4 radians (45 degrees), which will override the default body rotation, 0 radians. We're passing in a restitution property here which specifies the elasticity of the body. By default it's 0 (inelastic), so we're overriding it to create a slightly bouncy rectangle. Other useful properties include: friction, frictionAir, frictionStatic and density.</p>\n<p>The floor body can't be moved or rotated because we've flagged it as a static body using isStatic. So our rectangle will bounce off the floor without the floor moving.</p>\n<p>We can introduce a few new body types (polygons &amp; circles) and fill out our world:</p>\n<a href=\"https://medium.com/media/ec4f1b381c4050367506b41e68f6faf0/href\">https://medium.com/media/ec4f1b381c4050367506b41e68f6faf0/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*E-nijh7jebMvp9sEfNghUg.gif\"><figcaption>Since the rectangle has the highest friction and lowest restitution, it’s the least bouncy and slippery of the shapes.</figcaption></figure><p>We can also create compound bodies, bodies which have multiple parts that are linked together. The parts will move together as one object:</p>\n<a href=\"https://medium.com/media/af739ff62eb535982f4e93998730d1ab/href\">https://medium.com/media/af739ff62eb535982f4e93998730d1ab/href</a><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*bxzNlhrnuqGwaoLfG3ssgA.gif\"></figure><p>The last piece we’ll add is the ability to drop new polygons any time you click on the canvas:</p>\n<a href=\"https://medium.com/media/b8ce8b29a949e10687796b53e4d33c78/href\">https://medium.com/media/b8ce8b29a949e10687796b53e4d33c78/href</a><p>And putting it all together:</p>\n<a href=\"https://medium.com/media/a13d6b6f681c2104428b5a6df8698392/href\">https://medium.com/media/a13d6b6f681c2104428b5a6df8698392/href</a><p>Now that we’ve got the Matter fundamentals, we can turn our attention to working with Matter &amp; Phaser together. Check out this <a href=\"https://code.tutsplus.com/series/getting-started-with-matterjs--cms-1186\">tutorial series</a> by Monty Shokeen if you want to dive deeper into Matter by itself.</p>\n<h3>Matter and Phaser</h3>\n<p>We’ll create something similar to the last example, except we’ll use a tilemap to define the world and we’ll drop some emojis (because why not):</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*bhm6OCdBX1XoWnQ732OWIg.gif\"></figure><p>Using the same structure as the last tutorial in this series, we’ll create an index.js file that creates our game and loads a custom scene:</p>\n<a href=\"https://medium.com/media/fe99bd76b64a0ee020cf1746ade4c613/href\">https://medium.com/media/fe99bd76b64a0ee020cf1746ade4c613/href</a><p>Let’s start by creating MainScene which loads up the tilemap and enables physics:</p>\n<a href=\"https://medium.com/media/7356ab597c653e5a0f130bcecb8664a7/href\">https://medium.com/media/7356ab597c653e5a0f130bcecb8664a7/href</a><p>If we look closely, we can see that all the new bodies are rectangles. We’ll get into giving the tiles custom bodies that match their graphics in the next section.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*_hsPeZ-L_0kx51XVpcPWOw.png\"></figure><p>Now, we can drop a couple emojis with circle bodies into our scene using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#image__anchor\">this.matter.add.image</a>. Like with AP, we can create physics enabled images and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#sprite__anchor\">sprites</a> using the this.matter.add <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html\">factory methods</a>. The factory also has methods for creating native Matter bodies and constraints (without any graphics), e.g. this.matter.add.rectangle.</p>\n<a href=\"https://medium.com/media/35ee25c4fb43a81b24dfc8cd7c23e98c/href\">https://medium.com/media/35ee25c4fb43a81b24dfc8cd7c23e98c/href</a><p>These image variables are now instances of <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html\">Phaser.Physics.Matter.Image</a>. They have the properties and methods of a normal Phaser image, but with added methods and properties for manipulating the underlying Matter body. There's a body property which gives you access to the native Matter body, and methods like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setCircle__anchor\">setCircle</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setRectangle__anchor\">setRectangle</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setBody__anchor\">setBody</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Image.html#setExistingBody__anchor\">setExistingBody</a>, etc. for replacing the image's current body. The same idea applies to <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Sprite.html\">Phaser.Phyiscs.Matter.Sprite</a>.</p>\n<p>Like the Matter example from the previous section, we can add in some emojis every time the left mouse button is pressed by adding the following to our create method:</p>\n<a href=\"https://medium.com/media/f89a6c419fdb75c4d7965071007023b3/href\">https://medium.com/media/f89a6c419fdb75c4d7965071007023b3/href</a><p>And all together:</p>\n<a href=\"https://medium.com/media/40b8a26cce27f262afaacc3d85681c01/href\">https://medium.com/media/40b8a26cce27f262afaacc3d85681c01/href</a><h3>Mapping Collisions Shapes</h3>\n<p>We’ve got our tiles integrated with Matter, but we’ve got a problem. Our bodies are all rectangles, but our tiles aren’t all rectangles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/775/1*9GkvEr-xAVIgVMOkr24tVg.gif\"></figure><p>We’re not really taking advantage of Matter’s different body shapes… yet. In Tiled, we can map our collision shapes using the built-in <a href=\"http://docs.mapeditor.org/en/stable/manual/editing-tilesets/\">collision editor</a>. Phaser will automatically parse out circles, rectangles, polygons and compound shapes when we use this.matter.world.convertTilemapLayer(...).</p>\n<p>To map out the shapes in Tiled, we need to:</p>\n<ol>\n<li>Go to the tileset properties window and open the collision editor.</li>\n<li>Click on a tile and map out its body. Repeat for all the tiles that need custom bodies.</li>\n<li>Save the tileset &amp; re-export the tilemap.</li>\n</ol>\n<p>Tiled’s user interface can be a little confusing, so here’s how to open the collision editor:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Z2qKsJOR7ToWQYjXLd6bug.gif\"></figure><p>Once we’ve got a tile selected, we’ll have this window to map out the colliding shapes over the tile:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/506/1*vCARWcO6uJ8wK7XuOLwuag.png\"><figcaption>From left to right in the toolbar, the tools are: select object, edit polygon points, create rectangle, create ellipse, create polygon and create polyline. We’ll use all of them except for the polyline.</figcaption></figure><p>Let’s take a look at mapping out a few different tiles. The goal is to use the fewest number of shapes / vertices while still getting decently mapped hitboxes.</p>\n<p>First up, many tiles will work great with just a single rectangle, like this skinny platform:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GgFCvVMBepGtvrQo3svSFA.gif\"></figure><p>(As you are working, you may find it useful to enable or disable the snapping settings: View -&gt; Snapping in the top toolbar. In these GIFs, I have snap to pixels enabled.)</p>\n<p>Sometimes, all you need is a single circle:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*3JrH70qSpdMyNMyZzB-CnQ.gif\"></figure><p>One gotcha here — Matter doesn’t support ellipses, so any “ellipse” that you create in Tiled is going to be converted into a circle body inside of Phaser.</p>\n<p>Compound bodies made of multiple bodies — like our cross from earlier — can be handy, like for this switch:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*F2DTQ0Q2hvV8t2ER25UYvg.gif\"></figure><p>We can also map out polygons, like using a triangle for this sloped tile. (Press enter to complete the shape after drawing the last vertex.)</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Hg8nSnBgK9_L8Tq0oGhOuQ.gif\"></figure><p>Not all polygons are created equal. Convex polygons are usually much easier to deal with than concave polygons:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/509/1*ho-fMU_mCjnT3he2RAy2iQ.png\"><figcaption><em>Play with this </em><a href=\"https://www.mathopenref.com/polygonconvex.html\"><em>tool</em></a><em> to see what I mean by “interior angle.”</em></figcaption></figure><p>Convex polygons will work as expected. Any concave polygon bodies will be decomposed by Matter into a compound body of two or more convex polygons (using <a href=\"https://github.com/schteppe/poly-decomp.js\">poly-decomp.js</a>). If the decomposition fails, the body will set to a <a href=\"https://medium.com/@harshitsikchi/convex-hulls-explained-baab662c4e94\">convex hull</a>. See <a href=\"http://brm.io/matter-js/docs/classes/Bodies.html#method_fromVertices\">Matter docs</a> for more info. I’d recommend sticking to convex polygons, but we can map out a concave polygon for demo purposes:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mSmbXOsIA8lteK6OvsN5gQ.gif\"></figure><p>Save the tileset, re-export the map and we’ll have:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/476/1*VLJAknYYFDbA3bzaYwKKZg.gif\"><figcaption>This isn’t the same map we were using before —it’s just a small demo to show the tiles we just mapped. <em>Note, the debug rendering for the compound bodies — the sign and lava — also renders a convex hull. We’ll talk about that more next time.</em></figcaption></figure><p>In the codesandbox, I mapped out the rest of the tiles we’re using and exported the new map. No real need to change anything in the code to load up these new bodies:</p>\n<a href=\"https://medium.com/media/f532a1ce9de7049566e2032a5e4b67df/href\">https://medium.com/media/f532a1ce9de7049566e2032a5e4b67df/href</a><p>If we needed more control over the bodies given to tiles (or if we weren’t using Tiled), we can loop over the tiles using layer.forEachTile and use <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Matter.Factory.html#tileBody__anchor\">this.matter.add.tileBody</a> to add custom tile bodies to each tile.</p>\n<h3>Up Next</h3>\n<p>Stay tuned. Next up, we’ll use this foundational knowledge of Matter to build a platformer.</p>\n<p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=abf4dfa65ca1\" width=\"1\" height=\"1\"><hr>\n<p><a href=\"https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1\">Modular Game Worlds in Phaser 3 (Tilemaps #4) - Meet Matter.js</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["phaserjs", "javascript", "game-development", "programming"]
  },
  {
    "title": "Modular Game Worlds in Phaser 3 (Tilemaps #3) - Procedural Dungeon",
    "pubDate": "2018-07-23 04:13:28",
    "link":
      "https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd?source=rss-cc77752d538d------2",
    "guid": "https://medium.com/p/3bc19b841cd",
    "author": "Michael Hadley",
    "thumbnail": "https://cdn-images-1.medium.com/max/783/1*1nS56OTyac1FG-RpDD0rNw.gif",
    "description":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #3) — Procedural Dungeon</h3>\n<p>This is the third post in a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this edition, we’ll create an endless, procedurally-generated dungeon:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/783/1*1nS56OTyac1FG-RpDD0rNw.gif\"><figcaption>Tileset and Character by <a href=\"https://opengameart.org/users/buch\"><em>Michele “Buch” Bucelli</em></a></figcaption></figure><p>If you haven’t checked out the previous posts in the series, here are the links:</p>\n<ol>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">Static tilemaps &amp; a Pokémon-style world</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">Dynamic tilemaps &amp; puzzle-y platformer</a></li>\n</ol>\n<p>In the next post in the series, we’ll investigate using <a href=\"http://brm.io/matter-js/\">Matter.js</a> with tilemaps.</p>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-3\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser tutorial and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>Overview</h3>\n<p>This post builds on the idea of static vs dynamic tilemap layers that we talked about <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">last time</a>. The code we’re going to build in this post is based on one of my contributions to <a href=\"https://labs.phaser.io/\">Phaser Labs</a>. It was definitely the example I had the most fun making, and it conveniently covers a lot of additional parts of the dynamic tilemap layer API that we haven’t covered yet — from randomizing tiles to using per-tile transparency to create shadows.</p>\n<p>We’ll start by getting comfortable with a dungeon generator library using vanilla HTML &amp; JS. From there, we’ll start bringing in Phaser and progressively building out our endless dungeon world.</p>\n<h3>A Dungeon</h3>\n<p>We’re going to get a head start on generating worlds by using a dungeon generator library, <a href=\"https://github.com/mikewesthad/dungeon\">mikewesthad/dungeon</a>. It’s my updated fork of <a href=\"https://github.com/nickgravelyn/dungeon\">nickgravelyn/dungeon</a> that has a few new features, along with being published on npm. It’s a pretty simple, brute force dungeon generator. You give it some configuration info, and it randomly builds a dungeon room-by-room starting at the center of the map.</p>\n<p>You can load the library via a CDN, by downloading the script, or through npm (<a href=\"https://github.com/mikewesthad/dungeon#installation\">install instructions</a>). Once you’ve got the library loaded, you’ll have a Dungeon class that you can use to construct a dungeon instance like this:</p>\n<a href=\"https://medium.com/media/23e77946e2f32444a2116fcb3de713e3/href\">https://medium.com/media/23e77946e2f32444a2116fcb3de713e3/href</a><p>And we can visualize the random dungeon by generating some HTML via dungeon.drawToHtml which converts the dungeon to a &lt;pre&gt;&lt;table&gt; ... &lt;/table&gt;&lt;/pre&gt; HTML element. We just need to specify which characters we want to use for each type of \"tile\" in the dungeon:</p>\n<a href=\"https://medium.com/media/29c2160d5ebb8823c5122721a4c58ef8/href\">https://medium.com/media/29c2160d5ebb8823c5122721a4c58ef8/href</a><p>And voilà, emoji-goodness:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ugI6RdJnFMI2v5vRG1Rv2Q.gif\"></figure><a href=\"https://medium.com/media/d361d3908ddaba1aec5c9e5c51481ecb/href\">https://medium.com/media/d361d3908ddaba1aec5c9e5c51481ecb/href</a><p>With the interactive examples in this post, you’ll want to click on the “Edit on CodeSandbox” button and check out the code in full screen where you can see all the files easily.</p>\n<h3>Phaser &amp; Dungeon</h3>\n<p>Now we can introduce Phaser and put a player inside of these random worlds. The <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">previous post</a> in this series introduced the idea of using modules to better structure our code. Since modules aren’t common in the Phaser examples, I’ll break down the structure again here to help ease the transition.</p>\n<p>Remember, if you’re following along and not using CodeSandbox, you can get access to modules in your code by using &lt;script src=\"./js/index.js\" type=\"module\"&gt;&lt;/script&gt; in your HTML (see <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-3/02-dungeon-simple-mapping\">example</a>). You could, of course, also reach for Webpack, Parcel or any of the other JavaScript build tools. Check out <a href=\"https://github.com/photonstorm/phaser3-project-template\">phaser3-project-template</a> for a webpack starting template.</p>\n<p>On to the first example. Our directory structure looks like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/301/1*_kJHba5S2Hh4Dl3VAcnLaA.png\"></figure><p>“index.js” is the entry point for our code. This file kicks off things off by creating the Phaser game with arcade physics enabled and loading our custom scene:</p>\n<a href=\"https://medium.com/media/3ba71d8ca926f7c9f9c3db21b59f4fcd/href\">https://medium.com/media/3ba71d8ca926f7c9f9c3db21b59f4fcd/href</a><p>“dungeon-scene.js” is a module that exports a single class called DungeonScene. It extends <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html\">Phaser.Scene</a>, which means it has access to a bunch of Phaser functionality via properties (e.g. this.add for accessing the game object factory). The scene loads up some assets in preload, creates the dungeon and player in create and updates the player each frame inside of update.</p>\n<p>Once we’ve created a dungeon like we did in the last example, we can set up a tilemap with a blank layer using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createBlankDynamicLayer__anchor\">createBlankDynamicLayer</a>:</p>\n<a href=\"https://medium.com/media/a77a886c7a74712aae6ad2a2dc18141c/href\">https://medium.com/media/a77a886c7a74712aae6ad2a2dc18141c/href</a><p>Dungeon comes with an easy way to get a 2D array of tiles via dungeon.getMappedTiles, and Phaser has an easy way to insert an array of tiles into a layer via <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTilesAt__anchor\">putTilesAt</a>:</p>\n<a href=\"https://medium.com/media/8e102662ef2fa85e5a0d73381df38f08/href\">https://medium.com/media/8e102662ef2fa85e5a0d73381df38f08/href</a><p>And if we put this all together with a player module based on the code from the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">first post</a> in the series, we end up with:</p>\n<a href=\"https://medium.com/media/f3a0aa70e1e0d45c8b125faf11c2f902/href\">https://medium.com/media/f3a0aa70e1e0d45c8b125faf11c2f902/href</a><h3>A Closer Look at the Dungeon Tileset</h3>\n<p>Here’s the tileset that we’re using:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*to2RUPNgu4VM8PPSLeOHHA.png\"><figcaption><em>Unextruded image, </em><a href=\"https://opengameart.org/content/top-down-dungeon-tileset\"><em>dungeon tileset</em></a><em> by Michele “Buch” Bucelli (tileset artist) &amp; Abram Connelly (tileset sponsor)</em></figcaption></figure><p>And we want to use those tiles instead of our previously emoji-mapped dungeons, which looked like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/764/1*Q-pW0AGMEAl9CjLD7yOrZA.png\"></figure><p>We’ll need to choose which tiles to use for the floor, walls and doors. Because this tileset has perspective and directional lighting, we are also going to need to use different tiles for the corners and the north, west, south and east walls.</p>\n<p>Here are the specific tiles that we’ll be using to create our rooms:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2ei5rh7Zovzgyfi_SeOqBA.png\"></figure><p>Before jumping into code, I’ll usually play around with the tileset in <a href=\"https://www.mapeditor.org/\">Tiled</a> to get a feel for the tiles and how they fit together to create a room. Having a good plan in place is essential. Here’s a short timelapse of me planning out how two rooms intersect:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/709/1*VOL4tNnh6qpvMPAvGRtWBA.gif\"><figcaption><em>If you want to follow that process more closely, here’s a slower </em><a href=\"https://vimeo.com/281170034/f62b5d0dfe\"><em>video version</em></a><em>.</em></figcaption></figure><p>One important thing to note is that I’m using two layers here. We’ll want at least two layers when we get to Phaser — one for the ground &amp; walls and one for the chests/pots/etc. — so that we can use the tiles that have transparent backgrounds.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xsNas45jEaZ8Moqh7jwehw.png\"></figure><h3>Mapping Our World</h3>\n<p>Now that we’ve got a plan for how to use the tiles, we can get started with the mapping. By the end of this section, we’ll have this setup:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*6geu9RnjZr3FZy3uej-EmA.png\"></figure><p>We’re going to abandon the dungeon.getMappedTiles approach in favor of using the dungeon.roomsproperty. rooms is an array of objects with information about each room. A Room instance has the following properties:</p>\n<ul>\n<li>x, y - location of top left of the room (in grid units)</li>\n<li>width &amp; height</li>\n<li>top, left, bottom, right</li>\n<li>centerX &amp; centerY - integer center position (rounded down for even sized rooms)</li>\n</ul>\n<p>And one method:</p>\n<ul><li>getDoorLocations - gets an array of door locations ({x, y} objects) in coordinates relative to the room's top left</li></ul>\n<p>With those in mind, we can start mapping out our rooms:</p>\n<a href=\"https://medium.com/media/a03c846e643100460ffee26b8dbe9d10/href\">https://medium.com/media/a03c846e643100460ffee26b8dbe9d10/href</a><p>We’re going to be using the dynamic layer’s <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#fill__anchor\">fill</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAt__anchor\">putTileAt</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTilesAt__anchor\">putTilesAt</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#weightedRandomize__anchor\">weightedRandomize</a> methods to build out our map. Let's start with fill and weightedRandomize to make an initial pass at placing the floor and walls:</p>\n<a href=\"https://medium.com/media/fc16d87a39323e7c0006529a2be9bdec/href\">https://medium.com/media/fc16d87a39323e7c0006529a2be9bdec/href</a><p>And we’ll end up with a character trapped in a door-less world:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*mG37fRAI9JPlABo3QhUdsQ.png\"></figure><p>fill is straight forward. You can just pass in an index to fill the whole layer, or you can pass in x, y, width &amp; height parameters to fill a specific region.</p>\n<p>weightedRandomize might be new if you haven't used weighted probabilities. The first four parameters define the region we want to randomize (x, y, width, height). The last parameter describes which tiles to place and their probabilities. It's an array of objects that contains an index (or an array of indices) and a weight. The probability of any given index being used is: (the index's weight) / (sum of all weights for all indices).</p>\n<p>We’ve got something working, but the code is a bit hard to read. You have to mentally keep track of what the tile indices mean. Instead, let’s create a tile-mapping.js module that does that for us:</p>\n<a href=\"https://medium.com/media/20aaebf4fe3aac416adf2df0facc3724/href\">https://medium.com/media/20aaebf4fe3aac416adf2df0facc3724/href</a><p>Then back in our scene we can do something like the following:</p>\n<a href=\"https://medium.com/media/626a31f0b760c404f1a0b6d9df16126e/href\">https://medium.com/media/626a31f0b760c404f1a0b6d9df16126e/href</a><p>I’m starting to omit code so that we don’t have massive repeated code snippets in the article. If you get lost, hop down to the bottom of this section and check out the code sandbox. Now, to finish off our mapping, let’s add in some doors:</p>\n<a href=\"https://medium.com/media/dd8b6944e15a9eeef0cebe3661be0942/href\">https://medium.com/media/dd8b6944e15a9eeef0cebe3661be0942/href</a><p>Now we can add back in the player collision logic, similar to the last example:</p>\n<a href=\"https://medium.com/media/b8638701c359001fe592f9ecd5efb34e/href\">https://medium.com/media/b8638701c359001fe592f9ecd5efb34e/href</a><p>And we end up with:</p>\n<a href=\"https://medium.com/media/729dc5122c790bcfaa86d3ec9fc15111/href\">https://medium.com/media/729dc5122c790bcfaa86d3ec9fc15111/href</a><h3>Stuff &amp; Visibility</h3>\n<p>This is starting to feel more complete, so let’s kick it up by randomly placing some stuff in the rooms and then adding a visibility algorithm to create a fog of war effect:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/783/1*1nS56OTyac1FG-RpDD0rNw.gif\"></figure><p>For adding stuff, we’re going to want another layer:</p>\n<a href=\"https://medium.com/media/91469e360e4cd2b10cf750c46edec39d/href\">https://medium.com/media/91469e360e4cd2b10cf750c46edec39d/href</a><p>And then we can loop over the rooms again to place some stuff. We’re going to skip placing anything in the first room. We’re also going to designate a randomly selected room as the “goal” room, which will have a staircase that descends down to a new dungeon.</p>\n<a href=\"https://medium.com/media/376323df06d842bd3bb766893f9a8e00/href\">https://medium.com/media/376323df06d842bd3bb766893f9a8e00/href</a><p>Then once you activate collision on the new stuffLayer, you'll end up with:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/762/1*xazKLHt035zDtyfHwfhP5Q.gif\"></figure><p>And what would a rougelike dungeon be like without some sort of lighting effect? We’re going to go with something easy to show off the dynamic layer API, but you could implement something fun like a <a href=\"https://www.redblobgames.com/articles/visibility/\">ray casting approach</a> on your own.</p>\n<p>Unlike static map layers, dynamic layers can have per tile effects like tint and alpha. We’re going to take advantage of that by create a third tilemap layer which will just have blank, black tiles everywhere. They will start out completely opaque, but when a player enters a room, we’ll make the tiles “above” the room transparent so that the player can see. When they leave a room, we’ll “fog” the old room by making the black overlay of tiles semi-opaque.</p>\n<p>Inside of our scene’s create, we'll start by creating a new tilemap layer filled with black tiles and handing it off to a yet-to-be-created new module:</p>\n<a href=\"https://medium.com/media/fdecd84cf55bdaaf1e220a802456a1c6/href\">https://medium.com/media/fdecd84cf55bdaaf1e220a802456a1c6/href</a><p>Inside of “tilemap-visibility.js”, we’ll create a new class that keeps track of the currently active room and dims/brightens rooms as needed:</p>\n<a href=\"https://medium.com/media/6b2d1cdebae9949f9279ee57808fe3b2/href\">https://medium.com/media/6b2d1cdebae9949f9279ee57808fe3b2/href</a><p>And then lastly, inside of our scene’s update we just need to update the active room:</p>\n<a href=\"https://medium.com/media/d7d31d552852a29df556f52903b6a2a5/href\">https://medium.com/media/d7d31d552852a29df556f52903b6a2a5/href</a><p>Whew, and we finally end up with something like this:</p>\n<a href=\"https://medium.com/media/82aabbb91d8efd4f7766c05d56e61e55/href\">https://medium.com/media/82aabbb91d8efd4f7766c05d56e61e55/href</a><h3>Extras Bits: Descending the Stairs</h3>\n<p>In that last code example, I added a couple extra bits. Using tile index callbacks, we can detect when the player has reached the stairs and restart the scene to let the player enter a new dungeon. <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#setTileIndexCallback__anchor\">setTileIndexCallback</a>will set up a callback to run whenever an arcade body intersects a tile with the given index. It's useful in a situation like our game where we only have one moving body (the player). The relevant code inside of createlooks like this:</p>\n<a href=\"https://medium.com/media/90fd8aaa777d2ac67bb9ab632336e323/href\">https://medium.com/media/90fd8aaa777d2ac67bb9ab632336e323/href</a><p>I also added a level property to the scene so that we can tell the player what level they are on:</p>\n<a href=\"https://medium.com/media/4ac46edf564bf8a9ceb89ce49b36a517/href\">https://medium.com/media/4ac46edf564bf8a9ceb89ce49b36a517/href</a><h3>Up Next</h3>\n<p>Check out the next <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1\">post</a> where we’ll investigate using a more advanced physics engine — <a href=\"http://brm.io/matter-js/\">Matter.js</a> — with tilemaps:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*TMWo_mBNrA9StXQYj_T7FQ.gif\"></figure><p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3bc19b841cd\" width=\"1\" height=\"1\"><hr>\n<p><a href=\"https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd\">Modular Game Worlds in Phaser 3 (Tilemaps #3) - Procedural Dungeon</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "content":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #3) — Procedural Dungeon</h3>\n<p>This is the third post in a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this edition, we’ll create an endless, procedurally-generated dungeon:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/783/1*1nS56OTyac1FG-RpDD0rNw.gif\"><figcaption>Tileset and Character by <a href=\"https://opengameart.org/users/buch\"><em>Michele “Buch” Bucelli</em></a></figcaption></figure><p>If you haven’t checked out the previous posts in the series, here are the links:</p>\n<ol>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">Static tilemaps &amp; a Pokémon-style world</a></li>\n<li><a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">Dynamic tilemaps &amp; puzzle-y platformer</a></li>\n</ol>\n<p>In the next post in the series, we’ll investigate using <a href=\"http://brm.io/matter-js/\">Matter.js</a> with tilemaps.</p>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-3\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser tutorial and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>Overview</h3>\n<p>This post builds on the idea of static vs dynamic tilemap layers that we talked about <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">last time</a>. The code we’re going to build in this post is based on one of my contributions to <a href=\"https://labs.phaser.io/\">Phaser Labs</a>. It was definitely the example I had the most fun making, and it conveniently covers a lot of additional parts of the dynamic tilemap layer API that we haven’t covered yet — from randomizing tiles to using per-tile transparency to create shadows.</p>\n<p>We’ll start by getting comfortable with a dungeon generator library using vanilla HTML &amp; JS. From there, we’ll start bringing in Phaser and progressively building out our endless dungeon world.</p>\n<h3>A Dungeon</h3>\n<p>We’re going to get a head start on generating worlds by using a dungeon generator library, <a href=\"https://github.com/mikewesthad/dungeon\">mikewesthad/dungeon</a>. It’s my updated fork of <a href=\"https://github.com/nickgravelyn/dungeon\">nickgravelyn/dungeon</a> that has a few new features, along with being published on npm. It’s a pretty simple, brute force dungeon generator. You give it some configuration info, and it randomly builds a dungeon room-by-room starting at the center of the map.</p>\n<p>You can load the library via a CDN, by downloading the script, or through npm (<a href=\"https://github.com/mikewesthad/dungeon#installation\">install instructions</a>). Once you’ve got the library loaded, you’ll have a Dungeon class that you can use to construct a dungeon instance like this:</p>\n<a href=\"https://medium.com/media/23e77946e2f32444a2116fcb3de713e3/href\">https://medium.com/media/23e77946e2f32444a2116fcb3de713e3/href</a><p>And we can visualize the random dungeon by generating some HTML via dungeon.drawToHtml which converts the dungeon to a &lt;pre&gt;&lt;table&gt; ... &lt;/table&gt;&lt;/pre&gt; HTML element. We just need to specify which characters we want to use for each type of \"tile\" in the dungeon:</p>\n<a href=\"https://medium.com/media/29c2160d5ebb8823c5122721a4c58ef8/href\">https://medium.com/media/29c2160d5ebb8823c5122721a4c58ef8/href</a><p>And voilà, emoji-goodness:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ugI6RdJnFMI2v5vRG1Rv2Q.gif\"></figure><a href=\"https://medium.com/media/d361d3908ddaba1aec5c9e5c51481ecb/href\">https://medium.com/media/d361d3908ddaba1aec5c9e5c51481ecb/href</a><p>With the interactive examples in this post, you’ll want to click on the “Edit on CodeSandbox” button and check out the code in full screen where you can see all the files easily.</p>\n<h3>Phaser &amp; Dungeon</h3>\n<p>Now we can introduce Phaser and put a player inside of these random worlds. The <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">previous post</a> in this series introduced the idea of using modules to better structure our code. Since modules aren’t common in the Phaser examples, I’ll break down the structure again here to help ease the transition.</p>\n<p>Remember, if you’re following along and not using CodeSandbox, you can get access to modules in your code by using &lt;script src=\"./js/index.js\" type=\"module\"&gt;&lt;/script&gt; in your HTML (see <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/blob/master/examples/post-3/02-dungeon-simple-mapping\">example</a>). You could, of course, also reach for Webpack, Parcel or any of the other JavaScript build tools. Check out <a href=\"https://github.com/photonstorm/phaser3-project-template\">phaser3-project-template</a> for a webpack starting template.</p>\n<p>On to the first example. Our directory structure looks like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/301/1*_kJHba5S2Hh4Dl3VAcnLaA.png\"></figure><p>“index.js” is the entry point for our code. This file kicks off things off by creating the Phaser game with arcade physics enabled and loading our custom scene:</p>\n<a href=\"https://medium.com/media/3ba71d8ca926f7c9f9c3db21b59f4fcd/href\">https://medium.com/media/3ba71d8ca926f7c9f9c3db21b59f4fcd/href</a><p>“dungeon-scene.js” is a module that exports a single class called DungeonScene. It extends <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Scene.html\">Phaser.Scene</a>, which means it has access to a bunch of Phaser functionality via properties (e.g. this.add for accessing the game object factory). The scene loads up some assets in preload, creates the dungeon and player in create and updates the player each frame inside of update.</p>\n<p>Once we’ve created a dungeon like we did in the last example, we can set up a tilemap with a blank layer using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createBlankDynamicLayer__anchor\">createBlankDynamicLayer</a>:</p>\n<a href=\"https://medium.com/media/a77a886c7a74712aae6ad2a2dc18141c/href\">https://medium.com/media/a77a886c7a74712aae6ad2a2dc18141c/href</a><p>Dungeon comes with an easy way to get a 2D array of tiles via dungeon.getMappedTiles, and Phaser has an easy way to insert an array of tiles into a layer via <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTilesAt__anchor\">putTilesAt</a>:</p>\n<a href=\"https://medium.com/media/8e102662ef2fa85e5a0d73381df38f08/href\">https://medium.com/media/8e102662ef2fa85e5a0d73381df38f08/href</a><p>And if we put this all together with a player module based on the code from the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">first post</a> in the series, we end up with:</p>\n<a href=\"https://medium.com/media/f3a0aa70e1e0d45c8b125faf11c2f902/href\">https://medium.com/media/f3a0aa70e1e0d45c8b125faf11c2f902/href</a><h3>A Closer Look at the Dungeon Tileset</h3>\n<p>Here’s the tileset that we’re using:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/912/1*to2RUPNgu4VM8PPSLeOHHA.png\"><figcaption><em>Unextruded image, </em><a href=\"https://opengameart.org/content/top-down-dungeon-tileset\"><em>dungeon tileset</em></a><em> by Michele “Buch” Bucelli (tileset artist) &amp; Abram Connelly (tileset sponsor)</em></figcaption></figure><p>And we want to use those tiles instead of our previously emoji-mapped dungeons, which looked like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/764/1*Q-pW0AGMEAl9CjLD7yOrZA.png\"></figure><p>We’ll need to choose which tiles to use for the floor, walls and doors. Because this tileset has perspective and directional lighting, we are also going to need to use different tiles for the corners and the north, west, south and east walls.</p>\n<p>Here are the specific tiles that we’ll be using to create our rooms:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2ei5rh7Zovzgyfi_SeOqBA.png\"></figure><p>Before jumping into code, I’ll usually play around with the tileset in <a href=\"https://www.mapeditor.org/\">Tiled</a> to get a feel for the tiles and how they fit together to create a room. Having a good plan in place is essential. Here’s a short timelapse of me planning out how two rooms intersect:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/709/1*VOL4tNnh6qpvMPAvGRtWBA.gif\"><figcaption><em>If you want to follow that process more closely, here’s a slower </em><a href=\"https://vimeo.com/281170034/f62b5d0dfe\"><em>video version</em></a><em>.</em></figcaption></figure><p>One important thing to note is that I’m using two layers here. We’ll want at least two layers when we get to Phaser — one for the ground &amp; walls and one for the chests/pots/etc. — so that we can use the tiles that have transparent backgrounds.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*xsNas45jEaZ8Moqh7jwehw.png\"></figure><h3>Mapping Our World</h3>\n<p>Now that we’ve got a plan for how to use the tiles, we can get started with the mapping. By the end of this section, we’ll have this setup:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*6geu9RnjZr3FZy3uej-EmA.png\"></figure><p>We’re going to abandon the dungeon.getMappedTiles approach in favor of using the dungeon.roomsproperty. rooms is an array of objects with information about each room. A Room instance has the following properties:</p>\n<ul>\n<li>x, y - location of top left of the room (in grid units)</li>\n<li>width &amp; height</li>\n<li>top, left, bottom, right</li>\n<li>centerX &amp; centerY - integer center position (rounded down for even sized rooms)</li>\n</ul>\n<p>And one method:</p>\n<ul><li>getDoorLocations - gets an array of door locations ({x, y} objects) in coordinates relative to the room's top left</li></ul>\n<p>With those in mind, we can start mapping out our rooms:</p>\n<a href=\"https://medium.com/media/a03c846e643100460ffee26b8dbe9d10/href\">https://medium.com/media/a03c846e643100460ffee26b8dbe9d10/href</a><p>We’re going to be using the dynamic layer’s <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#fill__anchor\">fill</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAt__anchor\">putTileAt</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTilesAt__anchor\">putTilesAt</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#weightedRandomize__anchor\">weightedRandomize</a> methods to build out our map. Let's start with fill and weightedRandomize to make an initial pass at placing the floor and walls:</p>\n<a href=\"https://medium.com/media/fc16d87a39323e7c0006529a2be9bdec/href\">https://medium.com/media/fc16d87a39323e7c0006529a2be9bdec/href</a><p>And we’ll end up with a character trapped in a door-less world:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*mG37fRAI9JPlABo3QhUdsQ.png\"></figure><p>fill is straight forward. You can just pass in an index to fill the whole layer, or you can pass in x, y, width &amp; height parameters to fill a specific region.</p>\n<p>weightedRandomize might be new if you haven't used weighted probabilities. The first four parameters define the region we want to randomize (x, y, width, height). The last parameter describes which tiles to place and their probabilities. It's an array of objects that contains an index (or an array of indices) and a weight. The probability of any given index being used is: (the index's weight) / (sum of all weights for all indices).</p>\n<p>We’ve got something working, but the code is a bit hard to read. You have to mentally keep track of what the tile indices mean. Instead, let’s create a tile-mapping.js module that does that for us:</p>\n<a href=\"https://medium.com/media/20aaebf4fe3aac416adf2df0facc3724/href\">https://medium.com/media/20aaebf4fe3aac416adf2df0facc3724/href</a><p>Then back in our scene we can do something like the following:</p>\n<a href=\"https://medium.com/media/626a31f0b760c404f1a0b6d9df16126e/href\">https://medium.com/media/626a31f0b760c404f1a0b6d9df16126e/href</a><p>I’m starting to omit code so that we don’t have massive repeated code snippets in the article. If you get lost, hop down to the bottom of this section and check out the code sandbox. Now, to finish off our mapping, let’s add in some doors:</p>\n<a href=\"https://medium.com/media/dd8b6944e15a9eeef0cebe3661be0942/href\">https://medium.com/media/dd8b6944e15a9eeef0cebe3661be0942/href</a><p>Now we can add back in the player collision logic, similar to the last example:</p>\n<a href=\"https://medium.com/media/b8638701c359001fe592f9ecd5efb34e/href\">https://medium.com/media/b8638701c359001fe592f9ecd5efb34e/href</a><p>And we end up with:</p>\n<a href=\"https://medium.com/media/729dc5122c790bcfaa86d3ec9fc15111/href\">https://medium.com/media/729dc5122c790bcfaa86d3ec9fc15111/href</a><h3>Stuff &amp; Visibility</h3>\n<p>This is starting to feel more complete, so let’s kick it up by randomly placing some stuff in the rooms and then adding a visibility algorithm to create a fog of war effect:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/783/1*1nS56OTyac1FG-RpDD0rNw.gif\"></figure><p>For adding stuff, we’re going to want another layer:</p>\n<a href=\"https://medium.com/media/91469e360e4cd2b10cf750c46edec39d/href\">https://medium.com/media/91469e360e4cd2b10cf750c46edec39d/href</a><p>And then we can loop over the rooms again to place some stuff. We’re going to skip placing anything in the first room. We’re also going to designate a randomly selected room as the “goal” room, which will have a staircase that descends down to a new dungeon.</p>\n<a href=\"https://medium.com/media/376323df06d842bd3bb766893f9a8e00/href\">https://medium.com/media/376323df06d842bd3bb766893f9a8e00/href</a><p>Then once you activate collision on the new stuffLayer, you'll end up with:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/762/1*xazKLHt035zDtyfHwfhP5Q.gif\"></figure><p>And what would a rougelike dungeon be like without some sort of lighting effect? We’re going to go with something easy to show off the dynamic layer API, but you could implement something fun like a <a href=\"https://www.redblobgames.com/articles/visibility/\">ray casting approach</a> on your own.</p>\n<p>Unlike static map layers, dynamic layers can have per tile effects like tint and alpha. We’re going to take advantage of that by create a third tilemap layer which will just have blank, black tiles everywhere. They will start out completely opaque, but when a player enters a room, we’ll make the tiles “above” the room transparent so that the player can see. When they leave a room, we’ll “fog” the old room by making the black overlay of tiles semi-opaque.</p>\n<p>Inside of our scene’s create, we'll start by creating a new tilemap layer filled with black tiles and handing it off to a yet-to-be-created new module:</p>\n<a href=\"https://medium.com/media/fdecd84cf55bdaaf1e220a802456a1c6/href\">https://medium.com/media/fdecd84cf55bdaaf1e220a802456a1c6/href</a><p>Inside of “tilemap-visibility.js”, we’ll create a new class that keeps track of the currently active room and dims/brightens rooms as needed:</p>\n<a href=\"https://medium.com/media/6b2d1cdebae9949f9279ee57808fe3b2/href\">https://medium.com/media/6b2d1cdebae9949f9279ee57808fe3b2/href</a><p>And then lastly, inside of our scene’s update we just need to update the active room:</p>\n<a href=\"https://medium.com/media/d7d31d552852a29df556f52903b6a2a5/href\">https://medium.com/media/d7d31d552852a29df556f52903b6a2a5/href</a><p>Whew, and we finally end up with something like this:</p>\n<a href=\"https://medium.com/media/82aabbb91d8efd4f7766c05d56e61e55/href\">https://medium.com/media/82aabbb91d8efd4f7766c05d56e61e55/href</a><h3>Extras Bits: Descending the Stairs</h3>\n<p>In that last code example, I added a couple extra bits. Using tile index callbacks, we can detect when the player has reached the stairs and restart the scene to let the player enter a new dungeon. <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#setTileIndexCallback__anchor\">setTileIndexCallback</a>will set up a callback to run whenever an arcade body intersects a tile with the given index. It's useful in a situation like our game where we only have one moving body (the player). The relevant code inside of createlooks like this:</p>\n<a href=\"https://medium.com/media/90fd8aaa777d2ac67bb9ab632336e323/href\">https://medium.com/media/90fd8aaa777d2ac67bb9ab632336e323/href</a><p>I also added a level property to the scene so that we can tell the player what level they are on:</p>\n<a href=\"https://medium.com/media/4ac46edf564bf8a9ceb89ce49b36a517/href\">https://medium.com/media/4ac46edf564bf8a9ceb89ce49b36a517/href</a><h3>Up Next</h3>\n<p>Check out the next <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-4-meet-matter-js-abf4dfa65ca1\">post</a> where we’ll investigate using a more advanced physics engine — <a href=\"http://brm.io/matter-js/\">Matter.js</a> — with tilemaps:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*TMWo_mBNrA9StXQYj_T7FQ.gif\"></figure><p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3bc19b841cd\" width=\"1\" height=\"1\"><hr>\n<p><a href=\"https://itnext.io/modular-game-worlds-in-phaser-3-tilemaps-3-procedural-dungeon-3bc19b841cd\">Modular Game Worlds in Phaser 3 (Tilemaps #3) - Procedural Dungeon</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
    "enclosure": {},
    "categories": ["game-development", "programming", "javascript", "phaserjs"]
  }
]

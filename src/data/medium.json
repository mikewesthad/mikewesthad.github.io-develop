[
  {
    "title": "Modular Game Worlds in Phaser 3 (Tilemaps #2) — Dynamic Platformer",
    "pubDate": "2018-07-16 01:24:21",
    "link":
      "https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a?source=rss-cc77752d538d------2",
    "guid": "https://medium.com/p/3d68e73d494a",
    "author": "Michael Hadley",
    "thumbnail": "https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif",
    "description":
      "\n<p>This is a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. If you haven’t, check out the first <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">post</a> where we used static tilemaps to create a Pokémon-style game world. In this post, we’ll dive into dynamic tilemaps and create a puzzle-y platformer where you can draw platforms to help get around obstacles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"><figcaption><em>Final example that we’ll create</em></figcaption></figure><p>In the next posts in the series, we’ll create a procedural dungeon world and integrate <a href=\"http://brm.io/matter-js/\">Matter.js</a> to create a wall-jumping platformer.</p>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-2\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser <a href=\"https://phaser.io/tutorials/making-your-first-phaser-3-game\">tutorial</a> and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>The Tilemap API</h3>\n<p>Before we build the platformer, let’s start with a bird’s-eye view of the tilemap API. We talked about the following bits last time:</p>\n<ul>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html\">Tilemap</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tileset.html\">Tileset</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.StaticTilemapLayer.html\">StaticTilemapLayer</a></li>\n</ul>\n<p>In this post, we’ll dive into two new pieces of the API:</p>\n<ul>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html\">DynamicTilemapLayer</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile.html\">Tile</a></li>\n</ul>\n<p>A Tilemap isn't a display object. It holds data about the map and can contain one or more layers, which are the display objects that actually render Tile objects. They come in two flavors: StaticTilemapLayer &amp; DynamicTilemapLayer. A StaticTilemapLayer is fast, but its tiles can't be modified. A DynamicTilemapLayer trades some speed for the flexibility and power of manipulating individual tiles.</p>\n<p>Static and dynamic layers share much of the same API. They both have methods for checking whether a tile exists (e.g. hasTileAt). They both have methods for getting access to tiles in the map (getTileAt,findTile, forEachTile, etc.). Dynamic layers have a set of additional methods for adding, removing, randomizing, etc. tiles within the layer (e.g. putTileAt, removeTileAt, randomize, etc.).</p>\n<p>The tilemap API is flexible, so you can choose the right tool for the job. You can mix static and dynamic layers together in the same map. You can also convert a dynamic layer into a static layer, allowing you to generate a level on the fly and then optimize it.</p>\n<h3>Painting Tiles</h3>\n<p>For the first example, we’ll load up a level made with Tiled and then paint &amp; erase tiles on the fly. We couldn’t use static layers here, so we’ll need to reach for dynamic layers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*B8V3wwnoCR584DhYKFAj4A.gif\"><figcaption><em>Tileset by 0x72 under CC-0, </em><a href=\"https://0x72.itch.io/16x16-industrial-tileset\"><em>https://0x72.itch.io/16x16-industrial-tileset</em></a></figcaption></figure><p>We set up dynamic layers in the same way as static layers, except using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createDynamicLayer__anchor\">map.createDynamicLayer</a> instead of <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createStaticLayer__anchor\">map.createStaticLayer</a>:</p>\n<a href=\"https://medium.com/media/1d8e80ada47f606dc87004b654128ad0/href\">https://medium.com/media/1d8e80ada47f606dc87004b654128ad0/href</a><p>Once you’ve got a dynamic layer loaded up, you can start manipulating tiles using the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html\">DynamicTilemapLayer API</a>:</p>\n<a href=\"https://medium.com/media/86bd461caf54c4076d6b314bcc8144e6/href\">https://medium.com/media/86bd461caf54c4076d6b314bcc8144e6/href</a><p>The tilemap layer (and tilemap) methods that get or manipulate tiles often come in pairs. One method — like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAt__anchor\">putTileAt</a> - will operate on tile grid units, e.g. (0, 2) would correspond to the first column and third row of the layer. The other method - like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAtWorldXY__anchor\">putTileAtWorldXY</a> - will operate in world pixel units, making it easier to do things like find which tile is under the mouse. There are also methods for converting from tile grid units to world pixel coordinates and vice versa: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#worldToTileXY__anchor\">worldToTileXY</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#tileToWorldXY__anchor\">tileToWorldXY</a>.</p>\n<p>Putting these methods together with Phaser input, we can draw tiles in a layer with the mouse:</p>\n<a href=\"https://medium.com/media/94ddc41c27679c643593cf0697b7e29e/href\">https://medium.com/media/94ddc41c27679c643593cf0697b7e29e/href</a><p>The following example puts all of this together and allows you to paint tiles by clicking and erase tiles by clicking while holding shift. worldToTileXY &amp; tileToWorldXY are used to create a simple graphic overlay to visualize which tile the mouse is currently over.</p>\n<p>Note: you’ll want to click on the “Edit on CodeSandbox” button and check out the code in full screen where you can see all the files easily.</p>\n<a href=\"https://medium.com/media/252d8cae8d9a4436eb353543c834015a/href\">https://medium.com/media/252d8cae8d9a4436eb353543c834015a/href</a><h3>Modularizing Our Code</h3>\n<p>Adding or removing individual tiles is pretty easy, so let’s step up the complexity and build the foundations of a platformer:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*tc54eGD6Rh4-koyHhxMoGQ.gif\"></figure><p>Thus far, we’ve gotten up and running quickly with Phaser using a single file that has preload, setup and update functions. That's great for simple examples, but becomes a nightmare once you get to anything moderately complex.</p>\n<p>To build our platforming foundation, we want to split up that monolithic file structure into easier-to-digest, isolated files called “modules.” There are a lot of reasons go modular with your code. If used well, they help create portable &amp; reusable chunks of code that are easier to think about. If you aren’t familiar with modules, check out the <a href=\"https://eloquentjavascript.net/10_modules.html\">modules chapter</a> from <em>Eloquent JavaScript</em> or <a href=\"https://blog.cloud66.com/an-overview-of-es6-modules-in-javascript/\">this overview</a>.</p>\n<p>If you are using a modern browser (roughly anything late 2017 onward), you can use modules in your project (without needing webpack, parcel, etc.) by adding the type=\"module\" attribute in your HTML like this:</p>\n<a href=\"https://medium.com/media/e4b06e56c7ee1387cc7bcfc163289f00/href\">https://medium.com/media/e4b06e56c7ee1387cc7bcfc163289f00/href</a><p>(Note: you won’t see this in the CodeSandbox demos since they use the <a href=\"https://parceljs.org/\">Parcel bundler</a> to enable module support, but you will see it in the <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-2\">source code</a> for this series.)</p>\n<p>Inside of index.js, you can now <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\">import</a> functions, objects, or primitive values from other files that have at least one <a href=\"https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export\">export</a>. import and export provide ways for us to split our single file code into separate files. With that in mind, here's what our new project structure looks like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*7jHWzPxXCLaxs2gJijrJCQ.png\"></figure><a href=\"https://medium.com/media/42cd6d8bfa5000b17c5e52d6e04ce7f1/href\">https://medium.com/media/42cd6d8bfa5000b17c5e52d6e04ce7f1/href</a><p>Check out the code below, starting with index.js. From there, when you see an import, look at the file that's being referenced to follow the thread. This will be the basis we build upon for the next section.</p>\n<a href=\"https://medium.com/media/2226eb2dc052b79479ced2dd593b97b9/href\">https://medium.com/media/2226eb2dc052b79479ced2dd593b97b9/href</a><p>Breaking down every line of code here is a bit out of the scope of the post, but let’s look at a trimmed down version of player.js before moving on:</p>\n<a href=\"https://medium.com/media/2131b7a03279a3bf9a4b5931762f502b/href\">https://medium.com/media/2131b7a03279a3bf9a4b5931762f502b/href</a><p>This sets up an important pattern by letting us separate the bulk of the player logic from platformer-scene.js. The scene just has to worry about how the player interacts with the rest of the world. As long as we call updateand destroy at the right times, we could even bring this player file over to a completely separate project and it would work fine.</p>\n<p>It’s also worth noting that this class sets up a pattern that we’ll use again in the future. player.js exports a class that doesn’t extend Phaser.GameObjects.Sprite. Instead, it embraces a more flexible <a href=\"http://gameprogrammingpatterns.com/component.html\">component pattern</a> where Player has a sprite property rather than Player itself being a sprite.</p>\n<p>There’s a lot more that we could do to make this code more modular (e.g. taking advantage of Phaser’s event system, see <a href=\"https://github.com/samme/phaser-plugin-update\">samme/phaser-plugin-update</a>, or separating the movement logic from the animation), but this is modular enough without introducing too many new concepts.</p>\n<h3>The Platformer</h3>\n<p>Whew, we’ve got a template that we can build upon now. Let’s turn back to the idea of a platformer where you can draw tiles to get around obstacles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"></figure><p>There are two important tilemap-specific extensions to the code from the previous section that we should break down:</p>\n<ol>\n<li>Painting colliding tiles</li>\n<li>Adding spikes with proper hitboxes and logic</li>\n</ol>\n<p>First up, painting tiles. This is similar to previous code, but with the added wrinkle that we want the tiles that we add to be colliding, so that the player can land on them. putTileAtWorldXY will return the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile\">Tile</a> object that is being manipulated. Tile objects are pretty simple. They hold the index and position of the tile that they render, along with some physics information. We can use tile.setCollision to enable collisions:</p>\n<a href=\"https://medium.com/media/e2ce4b09198d81e27b920af543647b44/href\">https://medium.com/media/e2ce4b09198d81e27b920af543647b44/href</a><p>Tiles have other useful properties &amp; methods. tile.x and tile.y are the position in grid units. tile.getLeft(), tile.getBottom(), tile.getCenterX(), etc. will give you the position in world pixel units. Check out the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile\">docs</a> for more information.</p>\n<p>Perfect, we can paint tiles now. But we’ve got a spike problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*KzPiGzqnBorKdXy_4Xd5eA.gif\"></figure><p>One of the arcade physics (AP) limits in Phaser is that the physics body of colliding tiles is forced to be a rectangle that matches the tile width and tile height. Our spike is only 6px tall, but it’s given a 32px x 32px hitbox. If we load up the map and render the colliding tiles using this.groundLayer.renderDebug, the issue is more apparent:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/756/1*em4wU0VMhrwblsOiciO_7g.gif\"></figure><p>There are a few ways to solve this. We could switch to using Matter.js for physics, but that’s overkill. Instead, let’s convert the spikes from tiles into sprites, which we can give custom sized physics bodies. (…which also gives us a convenient excuse to look deeper at the tilemap API!)</p>\n<p>Tilemaps have methods for turning Tiled objects and tiles into sprites: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createFromObjects__anchor\">createFromObjects</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createFromTiles__anchor\">createFromTiles</a> respectively. You can these to visually lay out where your game entities should be - e.g. place Tiled objects where enemies should be in your level and then turn them into proper sprites when your game boots up. Here's a diagrammed <a href=\"https://labs.phaser.io/edit.html?src=src%5Cgame%20objects%5Ctilemap%5Cstatic%5Ccreate%20from%20objects.js&amp;v=3.9.0\">Phaser example</a> that uses this strategy to replace Tiled objects with animated coin sprites:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*as6XVjmqc7YogHXJtFUPcg.gif\"><figcaption><em>The left side is the Phaser example running in the browser and the right side is Tiled. Note how width/height/flip etc. are copied over to the animated coin sprites.</em></figcaption></figure><p>In the context of our code, turning spikes into sprites is a little more complicated, so we can roll our own custom version of tile → sprite logic by looping over all the Tile objects in a layer using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#forEachTile__anchor\">forEachTile</a>:</p>\n<a href=\"https://medium.com/media/5fa6e23800cb3b00b345fcb660bad173/href\">https://medium.com/media/5fa6e23800cb3b00b345fcb660bad173/href</a><p>And we’ll end up with nice hitboxes like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/756/1*Nm2nXVw5MJtCgnnSG8ERrg.gif\"></figure><p>Now for everything in context, where we reset the game when the player touches the spikes:</p>\n<a href=\"https://medium.com/media/db1c5be5c1658abe947c9c85564ecfb6/href\">https://medium.com/media/db1c5be5c1658abe947c9c85564ecfb6/href</a><h3>Up Next</h3>\n<p>Stay tuned. In the next two posts in the series, we’ll create a procedural dungeon with dynamic tilemaps and integrate <a href=\"http://brm.io/matter-js/\">Matter.js</a> to create a wall-jumping platformer.</p>\n<p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3d68e73d494a\" width=\"1\" height=\"1\">\n",
    "content":
      "\n<p>This is a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. If you haven’t, check out the first <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">post</a> where we used static tilemaps to create a Pokémon-style game world. In this post, we’ll dive into dynamic tilemaps and create a puzzle-y platformer where you can draw platforms to help get around obstacles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"><figcaption><em>Final example that we’ll create</em></figcaption></figure><p>In the next posts in the series, we’ll create a procedural dungeon world and integrate <a href=\"http://brm.io/matter-js/\">Matter.js</a> to create a wall-jumping platformer.</p>\n<p>Before we dive in, all the source code and assets that go along with this post can be found in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-2\">this repository</a>.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript (classes, arrow functions &amp; modules), Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, you might want to start at the beginning of the <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6\">series</a>, or continue reading and keep Google, the Phaser <a href=\"https://phaser.io/tutorials/making-your-first-phaser-3-game\">tutorial</a> and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>The Tilemap API</h3>\n<p>Before we build the platformer, let’s start with a bird’s-eye view of the tilemap API. We talked about the following bits last time:</p>\n<ul>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html\">Tilemap</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tileset.html\">Tileset</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.StaticTilemapLayer.html\">StaticTilemapLayer</a></li>\n</ul>\n<p>In this post, we’ll dive into two new pieces of the API:</p>\n<ul>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html\">DynamicTilemapLayer</a></li>\n<li><a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile.html\">Tile</a></li>\n</ul>\n<p>A Tilemap isn't a display object. It holds data about the map and can contain one or more layers, which are the display objects that actually render Tile objects. They come in two flavors: StaticTilemapLayer &amp; DynamicTilemapLayer. A StaticTilemapLayer is fast, but its tiles can't be modified. A DynamicTilemapLayer trades some speed for the flexibility and power of manipulating individual tiles.</p>\n<p>Static and dynamic layers share much of the same API. They both have methods for checking whether a tile exists (e.g. hasTileAt). They both have methods for getting access to tiles in the map (getTileAt,findTile, forEachTile, etc.). Dynamic layers have a set of additional methods for adding, removing, randomizing, etc. tiles within the layer (e.g. putTileAt, removeTileAt, randomize, etc.).</p>\n<p>The tilemap API is flexible, so you can choose the right tool for the job. You can mix static and dynamic layers together in the same map. You can also convert a dynamic layer into a static layer, allowing you to generate a level on the fly and then optimize it.</p>\n<h3>Painting Tiles</h3>\n<p>For the first example, we’ll load up a level made with Tiled and then paint &amp; erase tiles on the fly. We couldn’t use static layers here, so we’ll need to reach for dynamic layers.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*B8V3wwnoCR584DhYKFAj4A.gif\"><figcaption><em>Tileset by 0x72 under CC-0, </em><a href=\"https://0x72.itch.io/16x16-industrial-tileset\"><em>https://0x72.itch.io/16x16-industrial-tileset</em></a></figcaption></figure><p>We set up dynamic layers in the same way as static layers, except using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createDynamicLayer__anchor\">map.createDynamicLayer</a> instead of <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createStaticLayer__anchor\">map.createStaticLayer</a>:</p>\n<a href=\"https://medium.com/media/1d8e80ada47f606dc87004b654128ad0/href\">https://medium.com/media/1d8e80ada47f606dc87004b654128ad0/href</a><p>Once you’ve got a dynamic layer loaded up, you can start manipulating tiles using the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html\">DynamicTilemapLayer API</a>:</p>\n<a href=\"https://medium.com/media/86bd461caf54c4076d6b314bcc8144e6/href\">https://medium.com/media/86bd461caf54c4076d6b314bcc8144e6/href</a><p>The tilemap layer (and tilemap) methods that get or manipulate tiles often come in pairs. One method — like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAt__anchor\">putTileAt</a> - will operate on tile grid units, e.g. (0, 2) would correspond to the first column and third row of the layer. The other method - like <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#putTileAtWorldXY__anchor\">putTileAtWorldXY</a> - will operate in world pixel units, making it easier to do things like find which tile is under the mouse. There are also methods for converting from tile grid units to world pixel coordinates and vice versa: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#worldToTileXY__anchor\">worldToTileXY</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#tileToWorldXY__anchor\">tileToWorldXY</a>.</p>\n<p>Putting these methods together with Phaser input, we can draw tiles in a layer with the mouse:</p>\n<a href=\"https://medium.com/media/94ddc41c27679c643593cf0697b7e29e/href\">https://medium.com/media/94ddc41c27679c643593cf0697b7e29e/href</a><p>The following example puts all of this together and allows you to paint tiles by clicking and erase tiles by clicking while holding shift. worldToTileXY &amp; tileToWorldXY are used to create a simple graphic overlay to visualize which tile the mouse is currently over.</p>\n<p>Note: you’ll want to click on the “Edit on CodeSandbox” button and check out the code in full screen where you can see all the files easily.</p>\n<a href=\"https://medium.com/media/252d8cae8d9a4436eb353543c834015a/href\">https://medium.com/media/252d8cae8d9a4436eb353543c834015a/href</a><h3>Modularizing Our Code</h3>\n<p>Adding or removing individual tiles is pretty easy, so let’s step up the complexity and build the foundations of a platformer:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*tc54eGD6Rh4-koyHhxMoGQ.gif\"></figure><p>Thus far, we’ve gotten up and running quickly with Phaser using a single file that has preload, setup and update functions. That's great for simple examples, but becomes a nightmare once you get to anything moderately complex.</p>\n<p>To build our platforming foundation, we want to split up that monolithic file structure into easier-to-digest, isolated files called “modules.” There are a lot of reasons go modular with your code. If used well, they help create portable &amp; reusable chunks of code that are easier to think about. If you aren’t familiar with modules, check out the <a href=\"https://eloquentjavascript.net/10_modules.html\">modules chapter</a> from <em>Eloquent JavaScript</em> or <a href=\"https://blog.cloud66.com/an-overview-of-es6-modules-in-javascript/\">this overview</a>.</p>\n<p>If you are using a modern browser (roughly anything late 2017 onward), you can use modules in your project (without needing webpack, parcel, etc.) by adding the type=\"module\" attribute in your HTML like this:</p>\n<a href=\"https://medium.com/media/e4b06e56c7ee1387cc7bcfc163289f00/href\">https://medium.com/media/e4b06e56c7ee1387cc7bcfc163289f00/href</a><p>(Note: you won’t see this in the CodeSandbox demos since they use the <a href=\"https://parceljs.org/\">Parcel bundler</a> to enable module support, but you will see it in the <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-2\">source code</a> for this series.)</p>\n<p>Inside of index.js, you can now <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import\">import</a> functions, objects, or primitive values from other files that have at least one <a href=\"https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export\">export</a>. import and export provide ways for us to split our single file code into separate files. With that in mind, here's what our new project structure looks like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*7jHWzPxXCLaxs2gJijrJCQ.png\"></figure><a href=\"https://medium.com/media/42cd6d8bfa5000b17c5e52d6e04ce7f1/href\">https://medium.com/media/42cd6d8bfa5000b17c5e52d6e04ce7f1/href</a><p>Check out the code below, starting with index.js. From there, when you see an import, look at the file that's being referenced to follow the thread. This will be the basis we build upon for the next section.</p>\n<a href=\"https://medium.com/media/2226eb2dc052b79479ced2dd593b97b9/href\">https://medium.com/media/2226eb2dc052b79479ced2dd593b97b9/href</a><p>Breaking down every line of code here is a bit out of the scope of the post, but let’s look at a trimmed down version of player.js before moving on:</p>\n<a href=\"https://medium.com/media/2131b7a03279a3bf9a4b5931762f502b/href\">https://medium.com/media/2131b7a03279a3bf9a4b5931762f502b/href</a><p>This sets up an important pattern by letting us separate the bulk of the player logic from platformer-scene.js. The scene just has to worry about how the player interacts with the rest of the world. As long as we call updateand destroy at the right times, we could even bring this player file over to a completely separate project and it would work fine.</p>\n<p>It’s also worth noting that this class sets up a pattern that we’ll use again in the future. player.js exports a class that doesn’t extend Phaser.GameObjects.Sprite. Instead, it embraces a more flexible <a href=\"http://gameprogrammingpatterns.com/component.html\">component pattern</a> where Player has a sprite property rather than Player itself being a sprite.</p>\n<p>There’s a lot more that we could do to make this code more modular (e.g. taking advantage of Phaser’s event system, see <a href=\"https://github.com/samme/phaser-plugin-update\">samme/phaser-plugin-update</a>, or separating the movement logic from the animation), but this is modular enough without introducing too many new concepts.</p>\n<h3>The Platformer</h3>\n<p>Whew, we’ve got a template that we can build upon now. Let’s turn back to the idea of a platformer where you can draw tiles to get around obstacles:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"></figure><p>There are two important tilemap-specific extensions to the code from the previous section that we should break down:</p>\n<ol>\n<li>Painting colliding tiles</li>\n<li>Adding spikes with proper hitboxes and logic</li>\n</ol>\n<p>First up, painting tiles. This is similar to previous code, but with the added wrinkle that we want the tiles that we add to be colliding, so that the player can land on them. putTileAtWorldXY will return the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile\">Tile</a> object that is being manipulated. Tile objects are pretty simple. They hold the index and position of the tile that they render, along with some physics information. We can use tile.setCollision to enable collisions:</p>\n<a href=\"https://medium.com/media/e2ce4b09198d81e27b920af543647b44/href\">https://medium.com/media/e2ce4b09198d81e27b920af543647b44/href</a><p>Tiles have other useful properties &amp; methods. tile.x and tile.y are the position in grid units. tile.getLeft(), tile.getBottom(), tile.getCenterX(), etc. will give you the position in world pixel units. Check out the <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tile\">docs</a> for more information.</p>\n<p>Perfect, we can paint tiles now. But we’ve got a spike problem:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*KzPiGzqnBorKdXy_4Xd5eA.gif\"></figure><p>One of the arcade physics (AP) limits in Phaser is that the physics body of colliding tiles is forced to be a rectangle that matches the tile width and tile height. Our spike is only 6px tall, but it’s given a 32px x 32px hitbox. If we load up the map and render the colliding tiles using this.groundLayer.renderDebug, the issue is more apparent:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/756/1*em4wU0VMhrwblsOiciO_7g.gif\"></figure><p>There are a few ways to solve this. We could switch to using Matter.js for physics, but that’s overkill. Instead, let’s convert the spikes from tiles into sprites, which we can give custom sized physics bodies. (…which also gives us a convenient excuse to look deeper at the tilemap API!)</p>\n<p>Tilemaps have methods for turning Tiled objects and tiles into sprites: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createFromObjects__anchor\">createFromObjects</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#createFromTiles__anchor\">createFromTiles</a> respectively. You can these to visually lay out where your game entities should be - e.g. place Tiled objects where enemies should be in your level and then turn them into proper sprites when your game boots up. Here's a diagrammed <a href=\"https://labs.phaser.io/edit.html?src=src%5Cgame%20objects%5Ctilemap%5Cstatic%5Ccreate%20from%20objects.js&amp;v=3.9.0\">Phaser example</a> that uses this strategy to replace Tiled objects with animated coin sprites:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*as6XVjmqc7YogHXJtFUPcg.gif\"><figcaption><em>The left side is the Phaser example running in the browser and the right side is Tiled. Note how width/height/flip etc. are copied over to the animated coin sprites.</em></figcaption></figure><p>In the context of our code, turning spikes into sprites is a little more complicated, so we can roll our own custom version of tile → sprite logic by looping over all the Tile objects in a layer using <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.DynamicTilemapLayer.html#forEachTile__anchor\">forEachTile</a>:</p>\n<a href=\"https://medium.com/media/5fa6e23800cb3b00b345fcb660bad173/href\">https://medium.com/media/5fa6e23800cb3b00b345fcb660bad173/href</a><p>And we’ll end up with nice hitboxes like:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/756/1*Nm2nXVw5MJtCgnnSG8ERrg.gif\"></figure><p>Now for everything in context, where we reset the game when the player touches the spikes:</p>\n<a href=\"https://medium.com/media/db1c5be5c1658abe947c9c85564ecfb6/href\">https://medium.com/media/db1c5be5c1658abe947c9c85564ecfb6/href</a><h3>Up Next</h3>\n<p>Stay tuned. In the next two posts in the series, we’ll create a procedural dungeon with dynamic tilemaps and integrate <a href=\"http://brm.io/matter-js/\">Matter.js</a> to create a wall-jumping platformer.</p>\n<p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. I wrote the Tilemap API for Phaser 3 and created a ton of guided examples, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3d68e73d494a\" width=\"1\" height=\"1\">\n",
    "enclosure": {},
    "categories": ["javascript", "programming", "phaserjs", "game-development"]
  },
  {
    "title": "Modular Game Worlds in Phaser 3 (Tilemaps #1)",
    "pubDate": "2018-07-04 17:47:10",
    "link":
      "https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-1-958fc7e6bbd6?source=rss-cc77752d538d------2",
    "guid": "https://medium.com/p/958fc7e6bbd6",
    "author": "Michael Hadley",
    "thumbnail": "https://cdn-images-1.medium.com/max/588/1*Lq_shZnfjjiFEBmBOHk_qA.gif",
    "description":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #1) — Static Maps</h3>\n<p>This is a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this first post, we’ll go from zero to creating a Pokemon-style top down game world that a player can explore:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/588/1*Lq_shZnfjjiFEBmBOHk_qA.gif\"><figcaption>Final example we’ll create — graphics from <a href=\"https://github.com/Tuxemon/Tuxemon\">Tuxemon</a>.</figcaption></figure><p>The <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">next post</a> covers how to create a dynamic platformer and the posts after that will cover procedurally generated dungeons and wall-jumping maps with <a href=\"http://brm.io/matter-js/\">Matter.js</a>.</p>\n<p>Before we dive in, all the code that goes along with this post is in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-1\">this repository</a>.</p>\n<h3>Why</h3>\n<p>I’m a creative developer and educator at <a href=\"https://convergencedesignlab.org/\">Convergence Design Lab</a>, but I was brought on to the Phaser team in the sprint leading up to the initial public v3 release to develop the Tilemap API. I created ~40 guided examples and wrote weekly newsletter updates, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript, Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, keep reading but also keep Google, the Phaser <a href=\"https://phaser.io/tutorials/making-your-first-phaser-3-game\">tutorial</a> and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy to fill in any gaps.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>What is a Tilemap</h3>\n<p>A tilemap is a technique for creating a game world out of modular building blocks. When you break a world down into lego-like pieces, you get memory, performance and creative wins.</p>\n<p>Imagine trying to recreate Mario from scratch. Let’s say we decide to try loading each level as a giant image file. World 1–1 would be over 3500px wide:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*J9SXwGC4Sa4-iVcV9NFb5g.png\"><figcaption><a href=\"http://www.mariouniverse.com/maps-nes-smb/\">Image Source</a></figcaption></figure><p>We’d need a lot of pixels to store that first level and the other 31 levels in the NES game as images. Additionally, it would be hard to sync up the image with logic with the game. Which pixels can Mario stand on? Which pixels correspond to pipes he can enter?</p>\n<p>The tilemap approach defines a set of modular, regularly-sized <em>tiles</em> that we can use to build our levels. That way, we only need one image, a <em>tileset</em>:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/304/1*qmckz-4ppRl9i8-tEmGmHw.png\"><figcaption><a href=\"http://rmrk.net/index.php?topic=37002.0\"><em>Source</em></a><em>: Tileset by Nintendo, remixed by Arrow</em></figcaption></figure><p>So that 304px x 192px image holds the possibility of recreating all the levels of the original mario game, plus any new levels you can imagine. (*Of course, you’d still be missing a mustached man and a bipedal turtle, among other things.) Each tile is just 16 x 16 pixels. An arrangement of those tiles into a level is called a <em>tilemap</em>. With tilemap editing software, we can easily configure properties of the tiles too. For example, we can mark some tiles — like the ground tiles — as solid tiles that Mario can stand on.</p>\n<p>So with tilemaps, we’ve got a smaller image (performance &amp; memory win) that we can use to easily create and iterate on level designs (creative win).</p>\n<h3>Phaser 3 Basic Template</h3>\n<p>Before we jump into loading up some tilemaps in code, let’s take a look at the structure of a Phaser 3 game. In v3, games are structured around Sceneobjects. These are like State objects from v2, but more flexible.</p>\n<a href=\"https://medium.com/media/1739b63d32c186546aac5d71a0cfdae5/href\">https://medium.com/media/1739b63d32c186546aac5d71a0cfdae5/href</a><p>This is a template that you’ll see throughout the Phaser examples repository. It’s an easy way to get started. It creates a game and defines a scene as a collection of functions — preload, create and update.</p>\n<p>Here’s a slightly more complicated example that shows how to load and create a background and some text:</p>\n<a href=\"https://medium.com/media/e4dd778f83edb66d52c3a5471453cde8/href\">https://medium.com/media/e4dd778f83edb66d52c3a5471453cde8/href</a><p>There might be a lot of new concepts in this series if you haven’t used Phaser, so check out the extensive <a href=\"https://labs.phaser.io/\">examples</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> if you get lost.</p>\n<h3>First Step</h3>\n<p>Let’s start with the simplest setup and re-create a mini-mario level using this stripped down Mario tileset:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/176/1*nYRQLN_J6TOMcurufrT7TQ.png\"></figure><p>We’ll start with the boilerplate from the last section. Inside of preload, we can load up the tileset image:</p>\n<a href=\"https://medium.com/media/5b4f16362876d107b4bb9b060813d36f/href\">https://medium.com/media/5b4f16362876d107b4bb9b060813d36f/href</a><p>this refers to our current scene and this.load is the scene's loader which handles, well, the loading of assets. The create function won't get run until after all the assets in preload are done loading.</p>\n<a href=\"https://medium.com/media/86c138a8ff3b31477ba28260246a7644/href\">https://medium.com/media/86c138a8ff3b31477ba28260246a7644/href</a><p>level is just a 2D array of numbers, or <em>indices</em>, that point to a specific tile from our tileset. 0 is the top left tile, 1 is the one next to it, etc.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/724/1*3vPA0TTITmXu6OyfpsRjNA.png\"><figcaption>Mapping from tileset index to tile</figcaption></figure><p>Note: an index that is less than zero is considered an empty tile.</p>\n<a href=\"https://medium.com/media/1b9eaaefae6955a85b1cf1d6e06be630/href\">https://medium.com/media/1b9eaaefae6955a85b1cf1d6e06be630/href</a><p>Breaking down that code, we’ve got three main parts: a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html\">Tilemap</a>, a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tileset.html\">Tileset</a> and a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.StaticTilemapLayer.html\">StaticTilemapLayer</a>. You create a Tilemap through <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.GameObjectCreator.html#tilemap\">this.make.tilemap</a> (or <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.GameObjectFactory.html#tilemap\">this.add.tilemap</a>). This isn't a display object, rather, it holds data about the map and allows you to add tilesets &amp; tilemap layers.</p>\n<p>A map can have one or more layers, which are the display objects that actually render tiles from a Tileset. They come in two flavors: StaticTilemapLayer &amp; DynamicTilemapLayer. A StaticTilemapLayer is super fast, but the tiles in that layer can't be modified. A DynamicTilemapLayer trades some speed for the flexibility and power of manipulating individual tiles. For this post, we'll stick to static layers, but next time, we'll dive into dynamic layers.</p>\n<h3>Loading from a File: CSV</h3>\n<p>In addition to loading a map from a 2D array, you can also load it from a CSV:</p>\n<a href=\"https://medium.com/media/20bcd5ae833fffc66a5c9b22a31c206a/href\">https://medium.com/media/20bcd5ae833fffc66a5c9b22a31c206a/href</a><p>Note: this example is basically a copy of a Phaser <a href=\"https://labs.phaser.io/view.html?src=src/game%20objects/tilemap/static/csv-map.js\">example</a> which features Rich Davey &amp; Ilija Melentijević’s <a href=\"http://www.photonstorm.com/games/cat-astro-phi\">Cat Astro Phi</a> assets.</p>\n<a href=\"https://medium.com/media/0e2b4766e1b4bdc71f4f6fc88b666b06/href\">https://medium.com/media/0e2b4766e1b4bdc71f4f6fc88b666b06/href</a><p>We can easily add some interactivity here by letting the player pan around the world using Phaser’s camera system. The code is commented to explain the new pieces of Phaser used, but check out the Phaser <a href=\"https://labs.phaser.io/index.html?dir=camera/&amp;q=\">camera examples</a> for more on cameras.</p>\n<a href=\"https://medium.com/media/adcbe0103f38e79fbe96907918688ec3/href\">https://medium.com/media/adcbe0103f38e79fbe96907918688ec3/href</a><h3>Building a Map in Tiled</h3>\n<p>Loading from a 2D array or CSV is great when you want to test out something simple or you are generating a procedural world, but odds are, you’ll want a level design tool. That’s where <a href=\"https://www.mapeditor.org/\">Tiled</a> comes in. It’s a free, open source tilemap editor that can export to CSV, JSON and a bunch of other formats.</p>\n<p>We won’t dive into how to use Tiled — that’s an expansive topic by itself — so check out Tiled’s <a href=\"http://docs.mapeditor.org/en/stable/manual/introduction/\">documentation</a> and the Game from Scratch <a href=\"http://www.gamefromscratch.com/post/2015/10/14/Tiled-Map-Editor-Tutorial-Series.aspx\">tutorial series</a> for a crash course. You can also download the tilemaps (.tmx files) and tilesets from the demos <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-1/assets\">here</a>. Open them up, play around and you should get the hang of it.</p>\n<p>When working with Tiled to generate maps for Phaser, there are a few things you’ll want to make sure to do:</p>\n<ol>\n<li>When you load a tileset into your map, make sure to check the “Embed in map” option. (If you forget to do this, then you can click the embed tileset button the bottom of the screen.) See first two images below.</li>\n<li>Make sure you aren’t using a compressed “Tile Layer Format.” You can adjust that in map properties sidebar… which you can open by hitting “Map → Map Properties” in the top toolbar. See third image below.</li>\n<li>When you export your map, save it as a JSON file.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/482/1*y4FAFx7dgzTe_7a70O6lNQ.png\"><figcaption>Embedding a tileset when creating it</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/495/1*2Lx1bk5Qzn4cAVIeagkfHQ.png\"><figcaption>Embedding a tileset AFTER creating it</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/424/1*FMkefLoaNXtYoWtjYnqHHA.png\"><figcaption>Changing the tilemap format</figcaption></figure><h3>Loading a Tiled Map</h3>\n<p>Using the tilemapTiledJSON loader method, we can load up and display a tilemap that we've exported from Tiled:</p>\n<a href=\"https://medium.com/media/50fac6298345fa74c9ae77c199044d6d/href\">https://medium.com/media/50fac6298345fa74c9ae77c199044d6d/href</a><p>This step is mainly about connecting up data. To help making the naming slightly more clear, here’s where the names come from:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6vg2E6qe8Tj9fvBS_83i4A.gif\"></figure><p>You’ll notice that the map is composed of multiple layers placed on top of one another:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*9Zv7JbEoNWWzmqaD2idBPg.gif\"></figure><p>This is a common design pattern when working with Tiled. It allows us to separate out elements to be placed at different “depths” in the game. With these layers, we can ensure the “Below Player” layer (the ground &amp; path) are displayed under the player sprite and the “Above Player” layer (roof/statue/sign tops) are displayed on top of the player sprite. The “World” layer has all the rest of the stuff, including the colliding/solid stuff in the world.</p>\n<p>If we add in our camera code, we end up with:</p>\n<a href=\"https://medium.com/media/e379289b4547b356a607381fccccc07d/href\">https://medium.com/media/e379289b4547b356a607381fccccc07d/href</a><h3>Moving with Physics</h3>\n<p>Now that we’ve got a world, we can add a proper character to the world and have them walk around with physics. There are currently three physics engines that are integrated into Phaser: arcade physics (AP), matter.js and impact. AP is fast and simple, so that’s where we’ll start — we’ll get to matter.js later.</p>\n<p>In AP, you can create physics bodies that are either rectangles or circles. Rectangle bodies are <a href=\"https://www.gamasutra.com/view/feature/131833/when_two_hearts_collide_.php\">axis-aligned bounding boxes</a>, which roughly means they can’t be rotated. Colliding tiles in our map loaded up with AP will be given a rectangular body that matches the size of the tile.</p>\n<p>There are four things we’ll need to do:</p>\n<ol>\n<li>Mark certain tiles in the worldLayer as colliding so that AP knows to use them for collisions.</li>\n<li>Enable the AP physics engine.</li>\n<li>Create a physics-based sprite for the player.</li>\n<li>Set the player to collide with the worldLayer.</li>\n</ol>\n<p>The first step to use a tilemap with physics is that you need to mark which tiles should be solid (“colliding”). One way to do that would be to mark certain tile indices as colliding within a layer:</p>\n<a href=\"https://medium.com/media/581408303fe3ee3dec5fd47ae8cde121/href\">https://medium.com/media/581408303fe3ee3dec5fd47ae8cde121/href</a><p>If you are working with tile indices, then there’s <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollision__anchor\">setCollision</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionBetween__anchor\">setCollisionBetween</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionByExclusion__anchor\">setCollisionByExclusion</a>. But thinking in terms of indices is hard, so there's a better way: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionByProperty__anchor\">setCollisionByProperty</a>. Tiled allows you to add properties to a tileset via the <a href=\"http://docs.mapeditor.org/en/latest/manual/editing-tilesets/\">Tileset Editor</a>, so we can just mark which tiles collide directly in Tiled.</p>\n<p>Steps (or see GIF below):</p>\n<ol>\n<li>Open up the Tileset Editor by clicking on the “Edit Tileset” button (at the bottom right of screen).</li>\n<li>Click and drag (or CTRL + A) to select all the tiles.</li>\n<li>Under the properties window (left side of screen), click the plus icon and add a boolean property named “collides.”</li>\n<li>Select only the tiles that you want to collide and set “collides” to true by checking the box</li>\n<li>Re-export your map.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WK_DcoMMv5ds7V1Eiu0kTw.gif\"></figure><p>Back inside of Phaser, we can simply do the following to mark our colliding tiles within worldLayer:</p>\n<a href=\"https://medium.com/media/e6235d3e63a26eb12e34ce8f8253ff9f/href\">https://medium.com/media/e6235d3e63a26eb12e34ce8f8253ff9f/href</a><p>If you want to verify that you’ve got the right tiles marked as colliding, use the layer’s debug rendering:</p>\n<a href=\"https://medium.com/media/1423aef4bd98c703a224c2a0a51060c3/href\">https://medium.com/media/1423aef4bd98c703a224c2a0a51060c3/href</a><p>Which will look like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*Jjt1gLIuZnkifreaZlPTDw.png\"></figure><p>Once we’ve got tiles marked as colliding, we can add physics. In our game’s config, we can turn on the arcade physics engine by doing the following:</p>\n<a href=\"https://medium.com/media/3ed906886b0cd3a539463182c8ae64a0/href\">https://medium.com/media/3ed906886b0cd3a539463182c8ae64a0/href</a><p>We can create a simple player sprite that moves around using physics:</p>\n<a href=\"https://medium.com/media/16e8d35853d1c7540730fc0e035dab33/href\">https://medium.com/media/16e8d35853d1c7540730fc0e035dab33/href</a><p>Note: I’m using a texture atlas here. See this <a href=\"https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3\">tutorial</a> for more info.</p>\n<p>The last step is to collide the player and the tilemap layer against one another. We could use <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Arcade.World.html#collide__anchor\">collide</a> or <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Arcade.World.html#addCollider__anchor\">addCollider</a>. We'll go with the latter:</p>\n<a href=\"https://medium.com/media/82410490547924d426a09aff836f66fa/href\">https://medium.com/media/82410490547924d426a09aff836f66fa/href</a><p>And putting it all together, with a few extras like adding in player animations:</p>\n<a href=\"https://medium.com/media/c463bd07e0499f6612de61b9814f7215/href\">https://medium.com/media/c463bd07e0499f6612de61b9814f7215/href</a><p>There’s a whole lot of powerful stuff you can do with Tiled and Phaser to make the creative process of developing a game world easier. For example, the code for this section uses an <a href=\"http://docs.mapeditor.org/en/stable/manual/objects/\">object layer</a> to embed the player’s spawn point directly in the map.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Cdpt9HLQqIoofvVjLwwuRA.gif\"></figure><a href=\"https://medium.com/media/6163cf44e589ccec0dc9e049d7d69972/href\">https://medium.com/media/6163cf44e589ccec0dc9e049d7d69972/href</a><p>But that’s just scratching the surface! Keep an eye out for the next post, where we’ll dive into dynamic tilemap layers and creating a procedural dungeon.</p>\n<h3>Next Up</h3>\n<p>This is all just scratching the surface. Check out the next <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">post</a> where we dive into dynamic tilemap layers to create a puzzle-y platformer:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"></figure><p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>Addendum on Tile Bleeding</h3>\n<p>You may have noticed the word “extruded” in the name of the tileset in the last two sections. If you ever notice a slight “bleeding” in your tilemap where you start to see the seams between your tiles, one way to solve that is to extrude your tiles using a small command line utility I wrote called <a href=\"https://github.com/sporadic-labs/tile-extruder\">tile-extruder</a>.</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=958fc7e6bbd6\" width=\"1\" height=\"1\">\n",
    "content":
      "\n<h3>Modular Game Worlds in Phaser 3 (Tilemaps #1) — Static Maps</h3>\n<p>This is a series of blog posts about creating modular worlds with tilemaps in the <a href=\"http://phaser.io/\">Phaser 3</a> game engine. In this first post, we’ll go from zero to creating a Pokemon-style top down game world that a player can explore:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/588/1*Lq_shZnfjjiFEBmBOHk_qA.gif\"><figcaption>Final example we’ll create — graphics from <a href=\"https://github.com/Tuxemon/Tuxemon\">Tuxemon</a>.</figcaption></figure><p>The <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">next post</a> covers how to create a dynamic platformer and the posts after that will cover procedurally generated dungeons and wall-jumping maps with <a href=\"http://brm.io/matter-js/\">Matter.js</a>.</p>\n<p>Before we dive in, all the code that goes along with this post is in <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-1\">this repository</a>.</p>\n<h3>Why</h3>\n<p>I’m a creative developer and educator at <a href=\"https://convergencedesignlab.org/\">Convergence Design Lab</a>, but I was brought on to the Phaser team in the sprint leading up to the initial public v3 release to develop the Tilemap API. I created ~40 guided examples and wrote weekly newsletter updates, but I wanted to collect all of that information into a more guided and digestible format so that people can more easily jump into Phaser 3.</p>\n<h3>Intended Audience</h3>\n<p>This post will make the most sense if you have some experience with JavaScript, Phaser and the <a href=\"https://www.mapeditor.org/\">Tiled</a> map editor. If you don’t, keep reading but also keep Google, the Phaser <a href=\"https://phaser.io/tutorials/making-your-first-phaser-3-game\">tutorial</a> and the Phaser <a href=\"https://labs.phaser.io/\">examples</a> &amp; <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> handy to fill in any gaps.</p>\n<p>Alright, Let’s get into it!</p>\n<h3>What is a Tilemap</h3>\n<p>A tilemap is a technique for creating a game world out of modular building blocks. When you break a world down into lego-like pieces, you get memory, performance and creative wins.</p>\n<p>Imagine trying to recreate Mario from scratch. Let’s say we decide to try loading each level as a giant image file. World 1–1 would be over 3500px wide:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*J9SXwGC4Sa4-iVcV9NFb5g.png\"><figcaption><a href=\"http://www.mariouniverse.com/maps-nes-smb/\">Image Source</a></figcaption></figure><p>We’d need a lot of pixels to store that first level and the other 31 levels in the NES game as images. Additionally, it would be hard to sync up the image with logic with the game. Which pixels can Mario stand on? Which pixels correspond to pipes he can enter?</p>\n<p>The tilemap approach defines a set of modular, regularly-sized <em>tiles</em> that we can use to build our levels. That way, we only need one image, a <em>tileset</em>:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/304/1*qmckz-4ppRl9i8-tEmGmHw.png\"><figcaption><a href=\"http://rmrk.net/index.php?topic=37002.0\"><em>Source</em></a><em>: Tileset by Nintendo, remixed by Arrow</em></figcaption></figure><p>So that 304px x 192px image holds the possibility of recreating all the levels of the original mario game, plus any new levels you can imagine. (*Of course, you’d still be missing a mustached man and a bipedal turtle, among other things.) Each tile is just 16 x 16 pixels. An arrangement of those tiles into a level is called a <em>tilemap</em>. With tilemap editing software, we can easily configure properties of the tiles too. For example, we can mark some tiles — like the ground tiles — as solid tiles that Mario can stand on.</p>\n<p>So with tilemaps, we’ve got a smaller image (performance &amp; memory win) that we can use to easily create and iterate on level designs (creative win).</p>\n<h3>Phaser 3 Basic Template</h3>\n<p>Before we jump into loading up some tilemaps in code, let’s take a look at the structure of a Phaser 3 game. In v3, games are structured around Sceneobjects. These are like State objects from v2, but more flexible.</p>\n<a href=\"https://medium.com/media/1739b63d32c186546aac5d71a0cfdae5/href\">https://medium.com/media/1739b63d32c186546aac5d71a0cfdae5/href</a><p>This is a template that you’ll see throughout the Phaser examples repository. It’s an easy way to get started. It creates a game and defines a scene as a collection of functions — preload, create and update.</p>\n<p>Here’s a slightly more complicated example that shows how to load and create a background and some text:</p>\n<a href=\"https://medium.com/media/e4dd778f83edb66d52c3a5471453cde8/href\">https://medium.com/media/e4dd778f83edb66d52c3a5471453cde8/href</a><p>There might be a lot of new concepts in this series if you haven’t used Phaser, so check out the extensive <a href=\"https://labs.phaser.io/\">examples</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/index.html\">documentation</a> if you get lost.</p>\n<h3>First Step</h3>\n<p>Let’s start with the simplest setup and re-create a mini-mario level using this stripped down Mario tileset:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/176/1*nYRQLN_J6TOMcurufrT7TQ.png\"></figure><p>We’ll start with the boilerplate from the last section. Inside of preload, we can load up the tileset image:</p>\n<a href=\"https://medium.com/media/5b4f16362876d107b4bb9b060813d36f/href\">https://medium.com/media/5b4f16362876d107b4bb9b060813d36f/href</a><p>this refers to our current scene and this.load is the scene's loader which handles, well, the loading of assets. The create function won't get run until after all the assets in preload are done loading.</p>\n<a href=\"https://medium.com/media/86c138a8ff3b31477ba28260246a7644/href\">https://medium.com/media/86c138a8ff3b31477ba28260246a7644/href</a><p>level is just a 2D array of numbers, or <em>indices</em>, that point to a specific tile from our tileset. 0 is the top left tile, 1 is the one next to it, etc.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/724/1*3vPA0TTITmXu6OyfpsRjNA.png\"><figcaption>Mapping from tileset index to tile</figcaption></figure><p>Note: an index that is less than zero is considered an empty tile.</p>\n<a href=\"https://medium.com/media/1b9eaaefae6955a85b1cf1d6e06be630/href\">https://medium.com/media/1b9eaaefae6955a85b1cf1d6e06be630/href</a><p>Breaking down that code, we’ve got three main parts: a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html\">Tilemap</a>, a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tileset.html\">Tileset</a> and a <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.StaticTilemapLayer.html\">StaticTilemapLayer</a>. You create a Tilemap through <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.GameObjectCreator.html#tilemap\">this.make.tilemap</a> (or <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.GameObjects.GameObjectFactory.html#tilemap\">this.add.tilemap</a>). This isn't a display object, rather, it holds data about the map and allows you to add tilesets &amp; tilemap layers.</p>\n<p>A map can have one or more layers, which are the display objects that actually render tiles from a Tileset. They come in two flavors: StaticTilemapLayer &amp; DynamicTilemapLayer. A StaticTilemapLayer is super fast, but the tiles in that layer can't be modified. A DynamicTilemapLayer trades some speed for the flexibility and power of manipulating individual tiles. For this post, we'll stick to static layers, but next time, we'll dive into dynamic layers.</p>\n<h3>Loading from a File: CSV</h3>\n<p>In addition to loading a map from a 2D array, you can also load it from a CSV:</p>\n<a href=\"https://medium.com/media/20bcd5ae833fffc66a5c9b22a31c206a/href\">https://medium.com/media/20bcd5ae833fffc66a5c9b22a31c206a/href</a><p>Note: this example is basically a copy of a Phaser <a href=\"https://labs.phaser.io/view.html?src=src/game%20objects/tilemap/static/csv-map.js\">example</a> which features Rich Davey &amp; Ilija Melentijević’s <a href=\"http://www.photonstorm.com/games/cat-astro-phi\">Cat Astro Phi</a> assets.</p>\n<a href=\"https://medium.com/media/0e2b4766e1b4bdc71f4f6fc88b666b06/href\">https://medium.com/media/0e2b4766e1b4bdc71f4f6fc88b666b06/href</a><p>We can easily add some interactivity here by letting the player pan around the world using Phaser’s camera system. The code is commented to explain the new pieces of Phaser used, but check out the Phaser <a href=\"https://labs.phaser.io/index.html?dir=camera/&amp;q=\">camera examples</a> for more on cameras.</p>\n<a href=\"https://medium.com/media/adcbe0103f38e79fbe96907918688ec3/href\">https://medium.com/media/adcbe0103f38e79fbe96907918688ec3/href</a><h3>Building a Map in Tiled</h3>\n<p>Loading from a 2D array or CSV is great when you want to test out something simple or you are generating a procedural world, but odds are, you’ll want a level design tool. That’s where <a href=\"https://www.mapeditor.org/\">Tiled</a> comes in. It’s a free, open source tilemap editor that can export to CSV, JSON and a bunch of other formats.</p>\n<p>We won’t dive into how to use Tiled — that’s an expansive topic by itself — so check out Tiled’s <a href=\"http://docs.mapeditor.org/en/stable/manual/introduction/\">documentation</a> and the Game from Scratch <a href=\"http://www.gamefromscratch.com/post/2015/10/14/Tiled-Map-Editor-Tutorial-Series.aspx\">tutorial series</a> for a crash course. You can also download the tilemaps (.tmx files) and tilesets from the demos <a href=\"https://github.com/mikewesthad/phaser-3-tilemap-blog-posts/tree/master/examples/post-1/assets\">here</a>. Open them up, play around and you should get the hang of it.</p>\n<p>When working with Tiled to generate maps for Phaser, there are a few things you’ll want to make sure to do:</p>\n<ol>\n<li>When you load a tileset into your map, make sure to check the “Embed in map” option. (If you forget to do this, then you can click the embed tileset button the bottom of the screen.) See first two images below.</li>\n<li>Make sure you aren’t using a compressed “Tile Layer Format.” You can adjust that in map properties sidebar… which you can open by hitting “Map → Map Properties” in the top toolbar. See third image below.</li>\n<li>When you export your map, save it as a JSON file.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/482/1*y4FAFx7dgzTe_7a70O6lNQ.png\"><figcaption>Embedding a tileset when creating it</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/495/1*2Lx1bk5Qzn4cAVIeagkfHQ.png\"><figcaption>Embedding a tileset AFTER creating it</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/424/1*FMkefLoaNXtYoWtjYnqHHA.png\"><figcaption>Changing the tilemap format</figcaption></figure><h3>Loading a Tiled Map</h3>\n<p>Using the tilemapTiledJSON loader method, we can load up and display a tilemap that we've exported from Tiled:</p>\n<a href=\"https://medium.com/media/50fac6298345fa74c9ae77c199044d6d/href\">https://medium.com/media/50fac6298345fa74c9ae77c199044d6d/href</a><p>This step is mainly about connecting up data. To help making the naming slightly more clear, here’s where the names come from:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6vg2E6qe8Tj9fvBS_83i4A.gif\"></figure><p>You’ll notice that the map is composed of multiple layers placed on top of one another:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*9Zv7JbEoNWWzmqaD2idBPg.gif\"></figure><p>This is a common design pattern when working with Tiled. It allows us to separate out elements to be placed at different “depths” in the game. With these layers, we can ensure the “Below Player” layer (the ground &amp; path) are displayed under the player sprite and the “Above Player” layer (roof/statue/sign tops) are displayed on top of the player sprite. The “World” layer has all the rest of the stuff, including the colliding/solid stuff in the world.</p>\n<p>If we add in our camera code, we end up with:</p>\n<a href=\"https://medium.com/media/e379289b4547b356a607381fccccc07d/href\">https://medium.com/media/e379289b4547b356a607381fccccc07d/href</a><h3>Moving with Physics</h3>\n<p>Now that we’ve got a world, we can add a proper character to the world and have them walk around with physics. There are currently three physics engines that are integrated into Phaser: arcade physics (AP), matter.js and impact. AP is fast and simple, so that’s where we’ll start — we’ll get to matter.js later.</p>\n<p>In AP, you can create physics bodies that are either rectangles or circles. Rectangle bodies are <a href=\"https://www.gamasutra.com/view/feature/131833/when_two_hearts_collide_.php\">axis-aligned bounding boxes</a>, which roughly means they can’t be rotated. Colliding tiles in our map loaded up with AP will be given a rectangular body that matches the size of the tile.</p>\n<p>There are four things we’ll need to do:</p>\n<ol>\n<li>Mark certain tiles in the worldLayer as colliding so that AP knows to use them for collisions.</li>\n<li>Enable the AP physics engine.</li>\n<li>Create a physics-based sprite for the player.</li>\n<li>Set the player to collide with the worldLayer.</li>\n</ol>\n<p>The first step to use a tilemap with physics is that you need to mark which tiles should be solid (“colliding”). One way to do that would be to mark certain tile indices as colliding within a layer:</p>\n<a href=\"https://medium.com/media/581408303fe3ee3dec5fd47ae8cde121/href\">https://medium.com/media/581408303fe3ee3dec5fd47ae8cde121/href</a><p>If you are working with tile indices, then there’s <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollision__anchor\">setCollision</a>, <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionBetween__anchor\">setCollisionBetween</a> and <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionByExclusion__anchor\">setCollisionByExclusion</a>. But thinking in terms of indices is hard, so there's a better way: <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Tilemaps.Tilemap.html#setCollisionByProperty__anchor\">setCollisionByProperty</a>. Tiled allows you to add properties to a tileset via the <a href=\"http://docs.mapeditor.org/en/latest/manual/editing-tilesets/\">Tileset Editor</a>, so we can just mark which tiles collide directly in Tiled.</p>\n<p>Steps (or see GIF below):</p>\n<ol>\n<li>Open up the Tileset Editor by clicking on the “Edit Tileset” button (at the bottom right of screen).</li>\n<li>Click and drag (or CTRL + A) to select all the tiles.</li>\n<li>Under the properties window (left side of screen), click the plus icon and add a boolean property named “collides.”</li>\n<li>Select only the tiles that you want to collide and set “collides” to true by checking the box</li>\n<li>Re-export your map.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WK_DcoMMv5ds7V1Eiu0kTw.gif\"></figure><p>Back inside of Phaser, we can simply do the following to mark our colliding tiles within worldLayer:</p>\n<a href=\"https://medium.com/media/e6235d3e63a26eb12e34ce8f8253ff9f/href\">https://medium.com/media/e6235d3e63a26eb12e34ce8f8253ff9f/href</a><p>If you want to verify that you’ve got the right tiles marked as colliding, use the layer’s debug rendering:</p>\n<a href=\"https://medium.com/media/1423aef4bd98c703a224c2a0a51060c3/href\">https://medium.com/media/1423aef4bd98c703a224c2a0a51060c3/href</a><p>Which will look like this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*Jjt1gLIuZnkifreaZlPTDw.png\"></figure><p>Once we’ve got tiles marked as colliding, we can add physics. In our game’s config, we can turn on the arcade physics engine by doing the following:</p>\n<a href=\"https://medium.com/media/3ed906886b0cd3a539463182c8ae64a0/href\">https://medium.com/media/3ed906886b0cd3a539463182c8ae64a0/href</a><p>We can create a simple player sprite that moves around using physics:</p>\n<a href=\"https://medium.com/media/16e8d35853d1c7540730fc0e035dab33/href\">https://medium.com/media/16e8d35853d1c7540730fc0e035dab33/href</a><p>Note: I’m using a texture atlas here. See this <a href=\"https://www.codeandweb.com/texturepacker/tutorials/how-to-create-sprite-sheets-for-phaser3\">tutorial</a> for more info.</p>\n<p>The last step is to collide the player and the tilemap layer against one another. We could use <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Arcade.World.html#collide__anchor\">collide</a> or <a href=\"https://photonstorm.github.io/phaser3-docs/Phaser.Physics.Arcade.World.html#addCollider__anchor\">addCollider</a>. We'll go with the latter:</p>\n<a href=\"https://medium.com/media/82410490547924d426a09aff836f66fa/href\">https://medium.com/media/82410490547924d426a09aff836f66fa/href</a><p>And putting it all together, with a few extras like adding in player animations:</p>\n<a href=\"https://medium.com/media/c463bd07e0499f6612de61b9814f7215/href\">https://medium.com/media/c463bd07e0499f6612de61b9814f7215/href</a><p>There’s a whole lot of powerful stuff you can do with Tiled and Phaser to make the creative process of developing a game world easier. For example, the code for this section uses an <a href=\"http://docs.mapeditor.org/en/stable/manual/objects/\">object layer</a> to embed the player’s spawn point directly in the map.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Cdpt9HLQqIoofvVjLwwuRA.gif\"></figure><a href=\"https://medium.com/media/6163cf44e589ccec0dc9e049d7d69972/href\">https://medium.com/media/6163cf44e589ccec0dc9e049d7d69972/href</a><p>But that’s just scratching the surface! Keep an eye out for the next post, where we’ll dive into dynamic tilemap layers and creating a procedural dungeon.</p>\n<h3>Next Up</h3>\n<p>This is all just scratching the surface. Check out the next <a href=\"https://medium.com/@michaelwesthadley/modular-game-worlds-in-phaser-3-tilemaps-2-dynamic-platformer-3d68e73d494a\">post</a> where we dive into dynamic tilemap layers to create a puzzle-y platformer:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/790/1*gDH7ngacTtHrHwvP0aZz7w.gif\"></figure><p>Thanks for reading, and if there’s something you’d like to see in future posts, let me know!</p>\n<h3>Addendum on Tile Bleeding</h3>\n<p>You may have noticed the word “extruded” in the name of the tileset in the last two sections. If you ever notice a slight “bleeding” in your tilemap where you start to see the seams between your tiles, one way to solve that is to extrude your tiles using a small command line utility I wrote called <a href=\"https://github.com/sporadic-labs/tile-extruder\">tile-extruder</a>.</p>\n<h3>About Me</h3>\n<p>I’m a creative developer &amp; educator. You can see more of my work and get in touch <a href=\"https://www.mikewesthad.com/\">here</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=958fc7e6bbd6\" width=\"1\" height=\"1\">\n",
    "enclosure": {},
    "categories": ["programming", "phaserjs", "game-development", "javascript"]
  }
]
